<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Challenge Arena ‚Äî Tokens</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #050507;
  --panel: #0f1113;
  --accent1: #00ffff;
  --accent2: #7cff66;
  --glass: rgba(255,255,255,0.03);
}
* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; font-family: 'Poppins', sans-serif; background: radial-gradient(1200px 600px at 10% 10%, rgba(0,255,204,0.03), transparent), linear-gradient(180deg,#030304 0%, #07070a 100%); color: #eafcff; }
.container { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; padding: 24px; }
.panel { width: 100%; max-width: 500px; background: var(--panel); border-radius: 12px; padding: 14px; box-shadow: 0 6px 28px rgba(2,8,12,0.6), inset 0 0 30px rgba(0,255,204,0.02); border: 1px solid rgba(0,255,204,0.06); }
header { width: 100%; text-align: center; margin-bottom: 12px; }
h2 { margin: 6px 0; font-size: 20px; letter-spacing: 1px; }
.balance { margin: 6px 0; color: var(--accent2); font-weight: 600; }
button.primary { margin-top: 10px; padding: 10px 14px; border-radius: 10px; border: none; font-weight: 700; cursor: pointer; background: linear-gradient(90deg, var(--accent1), var(--accent2)); color: #001; box-shadow: 0 6px 18px rgba(0,255,204,0.08); }
.muted { color: #9fb8b2; font-size: 13px; }
.controls { display: flex; gap: 10px; margin-top: 10px; align-items: center; justify-content: center; }
.stake-input { width: 110px; padding: 8px; border-radius: 8px; border: 1px solid rgba(0,255,204,0.08); background: #050607; color: var(--accent1); font-weight: 600; text-align: center; }
.game-menu { display: flex; gap: 8px; ap-top: 12px; flex-wrap: wrap; justify-content: center; }
.game-option { padding: 8px 10px; border-radius: 10px; background: var(--glass); border: 1px solid rgba(255,255,255,0.02); cursor: pointer; font-weight: 600; }
.game-option.active { box-shadow: 0 8px 28px rgba(0,255,204,0.06); border: 1px solid rgba(0,255,204,0.12); }
.board-area { margin-top: 14px; width: 100%; display: flex; justify-content: center; align-items: center; min-height: 220px; flex-direction: column; }
.status { margin-top: 10px; font-weight: 600; color: #cde; text-align: center; }
.ready-btn { width: 120px; }
.large-btn { padding: 18px 22px; font-size: 18px; border-radius: 12px; background: linear-gradient(90deg, var(--accent1), var(--accent2)); color: #001; border: none; cursor: pointer; }
.go-box { padding: 22px 18px; border-radius: 12px; background: #020304; border: 1px solid rgba(0,255,204,0.06); }
.countdown { font-size: 28px; font-weight: 700; letter-spacing: 2px; }
.ttt-grid { display: grid; grid-template-columns: repeat(3, 80px); gap: 8px; justify-content: center; }
.ttt-cell { width: 80px; height: 80px; border-radius: 10px; background: #080a0b; display: flex; align-items: center; justify-content: center; font-size: 34px; cursor: pointer; border: 1px solid rgba(0,255,204,0.03); }
.ttt-cell:hover { transform: translateY(-3px); }
.topbar { position: fixed; top: 14px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; align-items: center; z-index: 30; }
.title { font-size: 20px; font-weight: 700; background: linear-gradient(90deg, var(--accent1), var(--accent2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.global-controls { display: flex; gap: 8px; align-items: center; background: rgba(0,0,0,0.45); padding: 8px 12px; border-radius: 12px; border: 1px solid rgba(0,255,204,0.04); }
.small { font-size: 13px; color: #9fc9c2; }
.glow-win { box-shadow: 0 0 30px rgba(124,255,102,0.12), 0 0 80px rgba(0,255,204,0.03); }
.center { display: flex; align-items: center; justify-content: center; }
</style>
</head>
<body>
<div class="container" id="gameScreen">
  <div class="topbar">
    <div class="title">üí† Challenge Arena</div>
    <div class="global-controls">
      <button class="primary small" id="resetBtn">Reset Data</button>
    </div>
  </div>
  <header>
    <h2 id="playerName">Player</h2>
    <div class="balance">Tokens: <span id="bal1">100</span></div>
  </header>
  <div class="panel">
    <div class="small muted center">Game Selection</div>
    <div class="game-menu" id="menu1">
      <div class="game-option active" data-game="reaction">‚ö° Reaction Duel</div>
      <div class="game-option" data-game="math">üßÆ Math Sprint</div>
      <div class="game-option" data-game="ttt">‚ùå‚≠ï Tic Tac Toe</div>
    </div>
    <div class="small muted center" style="margin-top:12px">Stake Amount</div>
    <div class="controls">
      <input id="stake1" class="stake-input" type="number" value="10" min="1" />
      <div class="muted">Tokens</div>
    </div>
    <div class="controls">
      <button class="primary ready-btn" id="create1">Create Challenge</button>
    </div>
    <div class="board-area" id="area1"></div>
    <div class="status" id="status1">Not Ready</div>
  </div>
</div>
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, collection, addDoc, query, where, orderBy, onSnapshot, serverTimestamp, deleteDoc } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js";

// Generate a simple UUID for local user ID
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyCxU57etJTjzv2hCqFFYqQyHEQcoebfsHE",
  authDomain: "wagering-59415.firebaseapp.com",
  projectId: "wagering-59415",
  storageBucket: "wagering-59415.firebasestorage.app",
  messagingSenderId: "1063169096719",
  appId: "1:1063169096719:web:e10a094630347b5fffb77a",
  measurementId: "G-PNND9Q37XQ"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ====== State ====== */
const state = {
  userId: local Stuart
localStorage.getItem('userId') || generateUUID(),
  username: 'Player' + Math.floor(Math.random() * 1000),
  balance: 100,
  selectedGame: 'reaction',
  ongoing: false,
  currentMatch: null,
  matches: [],
  matchUnsubscribe: null
};

// Save userId to localStorage
localStorage.setItem('userId', state.userId);

/* ====== Helpers ====== */
const el = id => document.getElementById(id);
function setStatus(txt) {
  const statusEl = el('status1');
  if (statusEl) statusEl.textContent = txt;
}
function updateBalance() {
  const balEl = el('bal1');
  if (balEl) balEl.textContent = state.balance;
}
let unsubscribeMatches = null;
let unsubscribeActiveMatches = null;

/* ====== User Balance Update ====== */
async function updateUserBalance() {
  try {
    await updateDoc(doc(db, 'users', state.userId), { balance: state.balance });
  } catch (error) {
    console.error('Error updating balance:', error.message);
  }
}

/* ====== Fetch User Data ====== */
async function fetchUserData() {
  try {
    const userDoc = doc(db, 'users', state.userId);
    const userSnap = await getDoc(userDoc);
    if (userSnap.exists()) {
      const data = userSnap.data();
      state.balance = data.balance || 100;
      state.username = data.username || state.username;
    } else {
      await setDoc(userDoc, { balance: 100, username: state.username });
      state.balance = 100;
    }
    updateBalance();
    const playerNameEl = el('playerName');
    if (playerNameEl) playerNameEl.textContent = state.username;
  } catch (error) {
    console.error('Error fetching user data:', error.message);
  }
}

/* ====== Reset Data ====== */
function setupReset() {
  const resetBtn = el('resetBtn');
  if (resetBtn) {
    resetBtn.addEventListener('click', async () => {
      try {
        state.userId = generateUUID();
        state.username = 'Player' + Math.floor(Math.random() * 1000);
        state.balance = 100;
        localStorage.setItem('userId', state.userId);
        await setDoc(doc(db, 'users', state.userId), { balance: 100, username: state.username });
        updateBalance();
        const playerNameEl = el('playerName');
        if (playerNameEl) playerNameEl.textContent = state.username;
        setStatus('Data reset. New session started.');
        renderAreas();
      } catch (error) {
        console.error('Error resetting data:', error.message);
        setStatus('Error resetting data.');
      }
    });
  }
}

/* ====== Match Listener ====== */
function setupMatchListener() {
  try {
    const q = query(collection(db, 'matches'), where('status', '==', 'open'), orderBy('createdAt', 'desc'));
    unsubscribeMatches = onSnapshot(q, (snap) => {
      state.matches = snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      if (!state.ongoing) renderAreas();
    }, (error) => {
      console.error('Error in match listener:', error.message);
    });
  } catch (error) {
    console.error('Error setting up match listener:', error.message);
  }
}

/* ====== Active Match Listener ====== */
function setupActiveMatchListener() {
  try {
    const q1 = query(collection(db, 'matches'), where('status', '==', 'active'), where('proposer', '==', state.userId));
    const q2 = query(collection(db, 'matches'), where('status', '==', 'active'), where('acceptor', '==', state.userId));
    unsubscribeActiveMatches = [
      onSnapshot(q1, handleActiveSnap, (error) => console.error('Error in proposer match listener:', error.message)),
      onSnapshot(q2, handleActiveSnap, (error) => console.error('Error in acceptor match listener:', error.message))
    ];
  } catch (error) {
    console.error('Error setting up active match listener:', error.message);
  }
}

function handleActiveSnap(snap) {
  snap.docs.forEach(d => {
    if (state.ongoing) return;
    const data = d.data();
    const role = data.proposer === state.userId ? 'player1' : 'player2';
    startMatch(data.game, data.stake, { matchId: d.id, opponentIsBot: false, role });
  });
}

/* ====== Menu Selection ====== */
function setupMenus() {
  const menu = el('menu1');
  if (menu) {
    menu.addEventListener('click', e => {
      const opt = e.target.closest('.game-option');
      if (!opt) return;
      menu.querySelectorAll('.game-option').forEach(o => o.classList.remove('active'));
      opt.classList.add('active');
      state.selectedGame = opt.dataset.game;
      setStatus('Selected: ' + opt.textContent.trim());
    });
  }
}

/* ====== Match Buttons ====== */
function setupMatches() {
  const createBtn = el('create1');
  const area1 = el('area1');
  if (createBtn) createBtn.addEventListener('click', createMatch);
  if (area1) area1.addEventListener('click', handleMatchClick);
}

/* ====== Create Match ====== */
async function createMatch() {
  if (state.ongoing) return;
  const stake = Number(el('stake1')?.value) || 1;
  if (stake < 1) {
    alert("Stake must be at least 1.");
    return;
  }
  if (state.balance < stake) {
    alert("Not enough Tokens to stake.");
    return;
  }
  try {
    const game = state.selectedGame;
    const docRef = await addDoc(collection(db, 'matches'), {
      proposer: state.userId,
      proposerName: state.username,
      game,
      stake,
      createdAt: serverTimestamp(),
      status: 'open'
    });
    setStatus('Match created. Waiting for opponent...');
    setTimeout(async () => {
      try {
        const docSnap = await getDoc(docRef);
        if (docSnap.exists() && docSnap.data().status === 'open') {
          await deleteDoc(docRef);
          startMatch(game, stake, { opponentIsBot: true });
        }
      } catch (error) {
        console.error('Error checking match for bot:', error.message);
      }
    }, 30000);
  } catch (error) {
    console.error('Error creating match:', error.message);
    setStatus('Error creating match.');
  }
}

/* ====== Handle Match Click ====== */
async function handleMatchClick(e) {
  try {
    const cancel = e.target.closest('.cancel-btn');
    if (cancel) {
      const id = cancel.dataset.id;
      const m = state.matches.find(m => m.id === id);
      if (m && m.proposer === state.userId) {
        await deleteDoc(doc(db, 'matches', id));
        setStatus('Match cancelled.');
      } else {
        alert("Cannot cancel this match.");
      }
      return;
    }
    const accept = e.target.closest('.accept-btn');
    if (accept) {
      const id = accept.dataset.id;
      const m = state.matches.find(m => m.id === id);
      if (!m) return;
      if (m.proposer === state.userId) {
        alert('You cannot accept your own match.');
        return;
      }
      if (state.balance < m.stake) {
        alert('Not enough tokens to accept.');
        return;
      }
      const matchRef = doc(db, 'matches', id);
      await updateDoc(matchRef, { 
        status: 'active',
        acceptor: state.userId,
        acceptorName: state.username,
        startedAt: serverTimestamp(),
        data: {},
        ready: { player1: false, player2: false },
        answers: { player1: null, player2: null },
        clicks: { player1: null, player2: null }
      });
      state.balance -= m.stake;
      updateBalance();
      await updateUserBalance();
      startMatch(m.game, m.stake, { matchId: id, opponentIsBot: false, role: 'player2' });
    }
  } catch (error) {
    console.error('Error handling match click:', error.message);
    setStatus('Error performing action.');
  }
}

/* ====== Render Areas with Matches ====== */
function renderAreas() {
  if (state.ongoing) return;
  const areaEl = el('area1');
  if (!areaEl) return;
  areaEl.innerHTML = '';
  if (state.matches.length === 0) {
    areaEl.innerHTML = '<div class="center muted">No open matches. Create one!</div>';
    return;
  }
  state.matches.forEach(m => {
    const box = document.createElement('div');
    box.className = 'panel';
    box.style.marginBottom = '12px';
    let actionBtn = '';
    if (m.proposer === state.userId) {
      actionBtn = `<button class="primary cancel-btn" data-id="${m.id}" style="background:#ff6b6b;color:#fff">Cancel</button>`;
    } else {
      actionBtn = `<button class="primary accept-btn" data-id="${m.id}" style="background:#4caf50;color:#fff">Accept</button>`;
    }
    box.innerHTML = `
      <div>Challenger: ${m.proposerName || m.proposer}</div>
      <div>Game: ${prettyGameName(m.game)}</div>
      <div>Stake: ${m.stake} tokens</div>
      <div class="controls" style="justify-content: space-around">
        ${actionBtn}
      </div>`;
    areaEl.appendChild(box);
  });
}

/* ====== Match Lifecycle ====== */
async function startMatch(game, stake, opts = {}) {
  try {
    const opponentIsBot = !!opts.opponentIsBot;
    state.ongoing = true;
    state.currentMatch = { game, stake, startedAt: Date.now(), opponentIsBot, ...opts };
    if (!opponentIsBot) {
      state.balance -= stake;
      updateBalance();
      await updateUserBalance();
    }
    setStatus('Match starting: ' + prettyGameName(game));
    if (opponentIsBot) {
      renderGameUI(game);
    } else {
      setupMatchSnapshot();
    }
  } catch (error) {
    console.error('Error starting match:', error.message);
    setStatus('Error starting match.');
    state.ongoing = false;
    state.currentMatch = null;
  }
}

function setupMatchSnapshot() {
  if (!state.currentMatch?.matchId) return;
  try {
    const matchRef = doc(db, 'matches', state.currentMatch.matchId);
    state.matchUnsubscribe = onSnapshot(matchRef, (snap) => {
      if (!snap.exists()) {
        console.error('Match document does not exist:', state.currentMatch.matchId);
        setStatus('Match no longer exists.');
        concludeMatchUI(false, false, 'Match cancelled.');
        return;
      }
      const data = snap.data();
      state.currentMatch.serverData = data;
      if (data.status === 'finished') {
        handleMatchFinish(data);
      } else {
        renderGameUI(state.currentMatch.game, data);
      }
    }, (error) => {
      console.error('Error in match snapshot:', error.message);
      setStatus('Error in match.');
    });
  } catch (error) {
    console.error('Error setting up match snapshot:', error.message);
    setStatus('Error setting up match.');
  }
}

/* ====== Rendering per-game UI ====== */
function prettyGameName(k) {
  return ({ reaction: 'Reaction Duel', math: 'Math Sprint', ttt: 'Tic Tac Toe' })[k] || k;
}

function renderGameUI(game, serverData = null) {
  const areaEl = el('area1');
  if (!areaEl) return;
  areaEl.innerHTML = '';
  if (state.currentMatch.opponentIsBot) {
    if (game === 'reaction') renderReactionBot();
    else if (game === 'math') renderMathSprintBot();
    else if (game === 'ttt') renderTicTacToeBot();
  } else {
    if (game === 'reaction') renderReactionMulti(serverData);
    else if (game === 'math') renderMathSprintMulti(serverData);
    else if (game === 'ttt') renderTicTacToeMulti(serverData);
  }
}

/* ====== Bot Games ====== */
function renderReactionBot() {
  const area = el('area1');
  if (!area) return;
  const box = document.createElement('div');
  box.className = 'go-box center';
  box.style.width = '100%';
  const text = document.createElement('div');
  text.className = 'countdown';
  text.textContent = 'Get Ready...';
  const btn = document.createElement('button');
  btn.className = 'large-btn';
  btn.textContent = 'PRESS';
  btn.disabled = true;
  box.append(text, document.createElement('br'), btn);
  area.appendChild(box);
  let go = false, resolved = false;
  let botReacted = false;
  let botTimeoutId = null;
  btn.addEventListener('click', () => handleClick());
  function handleClick() {
    if (resolved) return;
    if (!go) {
      resolved = true;
      finalizeMatch(false, 'Clicked early (foul).');
      return;
    }
    resolved = true;
    const playerTime = Date.now() - state.currentMatch.startedAt;
    if (botReacted) {
      finalizeMatch(false, 'Bot reacted faster!');
      return;
    }
    const opponentTime = botTimeoutId ? (Date.now() - state.currentMatch.startedAt) : playerTime + Math.random() * 500 - 250;
    if (playerTime < opponentTime) finalizeMatch(true, 'You reacted faster!');
    else finalizeMatch(false, 'Bot reacted faster!');
    if (botTimeoutId) clearTimeout(botTimeoutId);
  }
  const delay = 1200 + Math.floor(Math.random() * 2000);
  setTimeout(() => {
    go = true;
    text.textContent = 'GO!';
    btn.disabled = false;
    const botDelay = 200 + Math.floor(Math.random() * 400);
    botTimeoutId = setTimeout(() => {
      if (resolved) return;
      botReacted = true;
      resolved = true;
      finalizeMatch(false, 'Bot reacted faster!');
    }, botDelay);
  }, delay);
  setTimeout(() => {
    if (!resolved) {
      resolved = true;
      finalizeMatch(false, 'No one reacted in time.');
    }
  }, 8000);
}

function renderMathSprintBot() {
  const area = el('area1');
  if (!area) return;
  const problem = generateMathProblem();
  const box = document.createElement('div');
  box.style.width = '100%';
  box.innerHTML = `
    <div style="font-weight:700;margin-bottom:8px">Solve:</div>
    <div class="go-box" style="margin-bottom:8px"><div style="font-size:22px">${problem.question}</div></div>
    <input id="input1" type="number" class="stake-input" placeholder="Your answer" />
    <div style="margin-top:8px"><button id="submit1" class="primary">Submit</button></div>
    <div id="msg1" class="small muted" style="margin-top:8px"></div>`;
  area.appendChild(box);
  let resolved = false;
  const startTime = Date.now();
  let botAnswered = false;
  let botAnswer = null;
  const submit = el('submit1');
  const inp = el('input1');
  if (submit && inp) {
    submit.addEventListener('click', () => handleSubmit(inp.value));
  }
  function handleSubmit(value) {
    if (resolved) return;
    const numeric = Number(value);
    const msg = el('msg1');
    if (!msg) return;
    if (isNaN(numeric)) {
      msg.textContent = 'Enter a number.';
      return;
    }
    const correct = numeric === problem.answer;
    const time = Date.now() - startTime;
    msg.textContent = correct ? `Correct! (${time} ms)` : `Wrong (${time} ms)`;
    if (correct) {
      resolved = true;
      if (botAnswered && botAnswer && botAnswer.correct) {
        finalizeMatch(false, 'Bot answered first!');
        return;
      }
      const opponentTime = botAnswered && botAnswer ? botAnswer.time : (time + Math.random() * 1000 - 500);
      if (time < opponentTime) finalizeMatch(true, `Answered correctly in ${time} ms`);
      else finalizeMatch(false, 'Bot answered faster!');
    } else {
      resolved = true;
      const d1 = Math.abs(numeric - problem.answer);
      const d2 = Math.abs((Math.random() * 20 - 10) - problem.answer);
      if (d1 < d2) finalizeMatch(true, 'Both wrong, but you were closer!');
      else finalizeMatch(false, 'Both wrong, opponent was closer!');
    }
  }
  const willBeCorrect = Math.random() < 0.8;
  const botDelay = 400 + Math.floor(Math.random() * 1600);
  setTimeout(() => {
    if (resolved) return;
    botAnswered = true;
    botAnswer = { correct: willBeCorrect, time: Date.now() - startTime };
    if (willBeCorrect) {
      resolved = true;
      finalizeMatch(false, 'Bot answered correctly first!');
    }
  }, botDelay);
  setTimeout(() => {
    if (!resolved) {
      resolved = true;
      const v1 = Number(el('input1')?.value);
      const d1 = isNaN(v1) ? Infinity : Math.abs(v1 - problem.answer);
      const d2 = Math.abs((Math.random() * 20 - 10) - problem.answer);
      if (d1 === d2) finalizeDraw('No decisive answer ‚Äî draw');
      else finalizeMatch(d1 < d2, 'Time end ‚Äî closer answer wins');
    }
  }, 10000);
}

function renderTicTacToeBot() {
  const area = el('area1');
  if (!area) return;
  const board = document.createElement('div');
  board.style.width = '100%';
  board.className = 'center';
  const grid = document.createElement('div');
  grid.className = 'ttt-grid';
  const cells = [];
  for (let i = 0; i < 9; i++) {
    const c = document.createElement('div');
    c.className = 'ttt-cell';
    c.dataset.idx = i;
    c.addEventListener('click', () => tttClickBot(i));
    cells.push(c);
    grid.appendChild(c);
  }
  board.appendChild(grid);
  area.appendChild(board);
  let gameBoard = Array(9).fill(null);
  let current = 1;
  setStatus('TicTacToe ‚Äî Your turn (X)');
  function syncRender() {
    cells.forEach((cell, i) => {
      cell.textContent = gameBoard[i] === 1 ? 'X' : gameBoard[i] === 2 ? 'O' : '';
    });
  }
  function tttClickBot(i) {
    if (gameBoard[i] !== null || current !== 1 || state.ongoing === false) return;
    gameBoard[i] = 1;
    syncRender();
    const winner = checkTTTWinner(gameBoard);
    if (winner) {
      finalizeMatch(winner === 1, `TicTacToe ‚Äî ${winner === 1 ? 'You win' : 'Opponent wins'}`);
      return;
    }
    if (gameBoard.every(v => v !== null)) {
      finalizeDraw('TicTacToe ‚Äî Draw');
      return;
    }
    current = 2;
    setStatus('TicTacToe ‚Äî Opponent\'s turn (O)');
    setTimeout(() => {
      const available = gameBoard.map((v, i) => v === null ? i : null).filter(v => v !== null);
      if (available.length > 0) {
        let move = tttBotChooseMove(gameBoard, 2, 1);
        gameBoard[move] = 2;
        syncRender();
        const winner = checkTTTWinner(gameBoard);
        if (winner) {
          finalizeMatch(winner === 1, `TicTacToe ‚Äî ${winner === 1 ? 'You win' : 'Opponent wins'}`);
          return;
        }
        if (gameBoard.every(v => v !== null)) {
          finalizeDraw('TicTacToe ‚Äî Draw');
          return;
        }
        current = 1;
        setStatus('TicTacToe ‚Äî Your turn (X)');
      }
    }, 500);
  }
  function tttBotChooseMove(board, myMark = 2, oppMark = 1) {
    const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    for (const mark of [myMark, oppMark]) {
      for (const [a,b,c] of lines) {
        const vals = [board[a], board[b], board[c]];
        const empties = [a,b,c].filter(i => board[i] === null);
        const countMark = vals.filter(v => v === mark).length;
        if (countMark === 2 && empties.length === 1) return empties[0];
      }
    }
    if (board[4] === null) return 4;
    const corners = [0,2,6,8].filter(i => board[i] === null);
    if (corners.length > 0) return corners[Math.floor(Math.random() * corners.length)];
    const empties = board.map((v,i) => v === null ? i : null).filter(v => v !== null);
    return empties[Math.floor(Math.random() * empties.length)];
  }
}

/* ====== Multiplayer Games ====== */
async function renderReactionMulti(serverData) {
  if (!serverData || !state.currentMatch?.matchId) return;
  const area = el('area1');
  if (!area) return;
  const box = document.createElement('div');
  box.className = 'go-box center';
  box.style.width = '100%';
  const text = document.createElement('div');
  text.className = 'countdown';
  text.textContent = 'Get Ready...';
  const readyBtn = document.createElement('button');
  readyBtn.className = 'primary';
  readyBtn.textContent = 'Ready';
  const pressBtn = document.createElement('button');
  pressBtn.className = 'large-btn';
  pressBtn.textContent = 'PRESS';
  pressBtn.disabled = true;
  box.append(text, document.createElement('br'), readyBtn, pressBtn);
  area.appendChild(box);
  const matchRef = doc(db, 'matches', state.currentMatch.matchId);
  const role = state.currentMatch.role;
  const otherRole = role === 'player1' ? 'player2' : 'player1';
  let resolved = false;

  readyBtn.addEventListener('click', async () => {
    try {
      await updateDoc(matchRef, { [`ready.${role}`]: true });
      readyBtn.disabled = true;
    } catch (error) {
      console.error('Error setting ready status:', error.message);
      setStatus('Error preparing match.');
    }
  });

  pressBtn.addEventListener('click', async () => {
    if (resolved || pressBtn.disabled) return;
    try {
      await updateDoc(matchRef, { [`clicks.${role}`]: serverTimestamp() });
    } catch (error) {
      console.error('Error recording click:', error.message);
      setStatus('Error recording action.');
    }
  });

  if (serverData.status === 'finished') {
    handleMatchFinish(serverData);
    return;
  }

  if (serverData.goTime) {
    text.textContent = 'GO!';
    pressBtn.disabled = false;
  } else if (serverData.ready?.player1 && serverData.ready?.player2) {
    text.textContent = 'Both ready, waiting for GO...';
    if (role === 'player1' && !serverData.goTime) {
      try {
        await updateDoc(matchRef, { goTime: serverTimestamp() });
      } catch (error) {
        console.error('Error setting goTime:', error.message);
        setStatus('Error starting match.');
      }
    }
  } else {
    text.textContent = 'Waiting for both to ready...';
  }

  if (serverData.clicks?.player1 && serverData.clicks?.player2) {
    resolved = true;
    try {
      const playerTime = serverData.clicks[role].toMillis() - (serverData.goTime?.toMillis() || 0);
      const opponentTime = serverData.clicks[otherRole].toMillis() - (serverData.goTime?.toMillis() || 0);
      if (playerTime < opponentTime && playerTime >= 0) {
        await updateDoc(matchRef, { winner: role, status: 'finished' });
      } else {
        await updateDoc(matchRef, { winner: otherRole, status: 'finished' });
      }
    } catch (error) {
      console.error('Error resolving reaction match:', error.message);
      setStatus('Error resolving match.');
    }
  } else if (serverData.clicks?.[role] && !serverData.goTime) {
    resolved = true;
    await updateDoc(matchRef, { winner: otherRole, status: 'finished' });
    setStatus('You clicked too early!');
  }
}

async function renderMathSprintMulti(serverData) {
  if (!serverData || !state.currentMatch?.matchId) return;
  const area = el('area1');
  if (!area) return;
  const matchRef = doc(db, 'matches', state.currentMatch.matchId);
  const role = state.currentMatch.role;
  const otherRole = role === 'player1' ? 'player2' : 'player1';
  let problem;
  if (role === 'player1' && !serverData.question) {
    problem = generateMathProblem();
    try {
      await updateDoc(matchRef, { 
        question: problem.question,
        answer: problem.answer,
        startTime: serverTimestamp()
      });
    } catch (error) {
      console.error('Error setting math problem:', error.message);
      setStatus('Error setting up match.');
    }
  } else {
    problem = { question: serverData.question, answer: serverData.answer };
  }
  if (!problem?.question) {
    setStatus('Waiting for problem...');
    return;
  }
  const box = document.createElement('div');
  box.style.width = '100%';
  box.innerHTML = `
    <div style="font-weight:700;margin-bottom:8px">Solve:</div>
    <div class="go-box" style="margin-bottom:8px"><div style="font-size:22px">${problem.question}</div></div>
    <input id="input1" type="number" class="stake-input" placeholder="Your answer" />
    <div style="margin-top:8px"><button id="submit1" class="primary">Submit</button></div>
    <div id="msg1" class="small muted" style="margin-top:8px"></div>`;
  area.appendChild(box);
  let resolved = false;
  const submit = el('submit1');
  const inp = el('input1');
  if (submit && inp) {
    submit.addEventListener('click', async () => {
      if (resolved) return;
      const numeric = Number(inp.value);
      if (isNaN(numeric) || inp.value === '') {
        const msg = el('msg1');
        if (msg) msg.textContent = 'Enter a number.';
        return;
      }
      try {
        await updateDoc(matchRef, { [`answers.${role}`]: { answer: numeric, submitTime: serverTimestamp() } });
      } catch (error) {
        console.error('Error submitting answer:', error.message);
        setStatus('Error submitting answer.');
      }
    });
  }

  if (serverData.answers?.player1 && serverData.answers?.player2) {
    resolved = true;
    try {
      const correctAnswer = serverData.answer;
      if (!correctAnswer) return;
      const playerAns = serverData.answers[role];
      const oppAns = serverData.answers[otherRole];
      const playerCorrect = playerAns.answer === correctAnswer;
      const oppCorrect = oppAns.answer === correctAnswer;
      if (playerCorrect && oppCorrect) {
        const playerTime = playerAns.submitTime.toMillis() - (serverData.startTime?.toMillis() || 0);
        const oppTime = oppAns.submitTime.toMillis() - (serverData.startTime?.toMillis() || 0);
        if (playerTime < oppTime) {
          await updateDoc(matchRef, { winner: role, status: 'finished' });
        } else {
          await updateDoc(matchRef, { winner: otherRole, status: 'finished' });
        }
      } else if (playerCorrect) {
        await updateDoc(matchRef, { winner: role, status: 'finished' });
      } else if (oppCorrect) {
        await updateDoc(matchRef, { winner: otherRole, status: 'finished' });
      } else {
        const playerDiff = Math.abs(playerAns.answer - correctAnswer);
        const oppDiff = Math.abs(oppAns.answer - correctAnswer);
        if (playerDiff < oppDiff) {
          await updateDoc(matchRef, { winner: role, status: 'finished' });
        } else if (playerDiff > oppDiff) {
          await updateDoc(matchRef, { winner: otherRole, status: 'finished' });
        } else {
          await updateDoc(matchRef, { draw: true, status: 'finished' });
        }
      }
    } catch (error) {
      console.error('Error resolving math sprint:', error.message);
      setStatus('Error resolving match.');
    }
  }
}

async function renderTicTacToeMulti(serverData) {
  if (!serverData || !state.currentMatch?.matchId) return;
  const area = el('area1');
  if (!area) return;
  const matchRef = doc(db, 'matches', state.currentMatch.matchId);
  const role = state.currentMatch.role;
  const otherRole = role === 'player1' ? 'player2' : 'player1';
  const myMark = role === 'player1' ? 'X' : 'O';
  if (!serverData.data?.board) {
    if (role === 'player1') {
      try {
        await updateDoc(matchRef, { 
          data: { board: Array(9).fill(null), turn: 'player1' } 
        });
      } catch (error) {
        console.error('Error initializing TTT board:', error.message);
        setStatus('Error setting up match.');
      }
    }
    return;
  }
  const boardDiv = document.createElement('div');
  boardDiv.style.width = '100%';
  boardDiv.className = 'center';
  const grid = document.createElement('div');
  grid.className = 'ttt-grid';
  const cells = [];
  for (let i = 0; i < 9; i++) {
    const c = document.createElement('div');
    c.className = 'ttt-cell';
    c.dataset.idx = i;
    c.addEventListener('click', async () => {
      if (serverData.data.turn !== role || serverData.data.board[i] !== null || state.ongoing === false) return;
      try {
        const newBoard = [...serverData.data.board];
        newBoard[i] = role === 'player1' ? 1 : 2;
        await updateDoc(matchRef, { 'data.board': newBoard, 'data.turn': otherRole });
      } catch (error) {
        console.error('Error making TTT move:', error.message);
        setStatus('Error making move.');
      }
    });
    cells.push(c);
    grid.appendChild(c);
  }
  boardDiv.appendChild(grid);
  area.appendChild(boardDiv);

  cells.forEach((cell, i) => {
    cell.textContent = serverData.data.board[i] === 1 ? 'X' : serverData.data.board[i] === 2 ? 'O' : '';
  });
  setStatus(`TicTacToe ‚Äî ${serverData.data.turn === role ? 'Your' : 'Opponent\'s'} turn (${myMark})`);

  const winnerNum = checkTTTWinner(serverData.data.board);
  if (winnerNum) {
    const winnerRole = winnerNum === 1 ? 'player1' : 'player2';
    try {
      await updateDoc(matchRef, { winner: winnerRole, status: 'finished' });
    } catch (error) {
      console.error('Error finalizing TTT match:', error.message);
      setStatus('Error finalizing match.');
    }
  } else if (serverData.data.board.every(v => v !== null)) {
    try {
      await updateDoc(matchRef, { draw: true, status: 'finished' });
    } catch (error) {
      console.error('Error setting draw:', error.message);
      setStatus('Error finalizing match.');
    }
  }
}

/* ====== Finalize Match Results ====== */
function handleMatchFinish(data) {
  const role = state.currentMatch?.role;
  if (!role) return;
  let won = false, draw = false, reason = '';
  if (data.draw) {
    draw = true;
    reason = 'Draw!';
  } else if (data.winner === role) {
    won = true;
    reason = 'You win!';
  } else {
    reason = 'Opponent wins!';
  }
  concludeMatchUI(won, draw, reason);
}

async function finalizeMatch(won, reason = '') {
  try {
    const stake = state.currentMatch?.stake || 0;
    if (won) state.balance += stake * 2;
    updateBalance();
    await updateUserBalance();
    if (won) {
      const areaParent = el('area1')?.parentElement;
      if (areaParent) areaParent.classList.add('glow-win');
    }
    concludeMatchUI(won, false, reason ? `You win! ${reason}` : `Opponent wins! ${reason}`);
  } catch (error) {
    console.error('Error finalizing match:', error.message);
    setStatus('Error finalizing match.');
  }
}

async function finalizeDraw(reason = '') {
  try {
    const stake = state.currentMatch?.stake || 0;
    state.balance += stake;
    updateBalance();
    await updateUserBalance();
    concludeMatchUI(false, true, 'Draw! ' + reason);
  } catch (error) {
    console.error('Error finalizing draw:', error.message);
    setStatus('Error finalizing match.');
  }
}

function concludeMatchUI-panels ui-button--large-btn center" id="resetBtn">Reset Data</button>
  </div>
  <div class="controls">
    <button class="primary ready-btn" id="create1">Create Challenge</button>
  </div>
  <div class="board-area" id="area1"></div>
  <div class="status" id="status1">Not Ready</div>
</div>
<script type="module">
  state.ongoing = false;
  if (state.matchUnsubscribe) {
    state.matchUnsubscribe();
    state.matchUnsubscribe = null;
  }
  state.currentMatch = null;
  updateBalance();
  renderAreas();
  el('area1').parentElement.classList.remove('glow-win');
}, 1600);
</script>
</body>
</html>

### Key Changes and Fixes

1. **Firestore Security Rules**:
   - Added error handling for Firestore operations to catch permission errors.
   - Assumes Firestore rules allow:
     ```javascript
     rules_version = "2";
     service cloud.firestore {
       match /matches/{matchId} {
         allow read: if true;
         allow write: if true;
         allow delete: if request.auth.uid == proposer || request.auth.uid == acceptor;
       }
       match /users/{userId} {
         allow read: if true;
         allow write: if true;
       }
     }
     ```
     Update your Firestore security rules to match these permissions to avoid "Permission denied" errors.

2. **Null/Undefined Checks**:
   - Added checks for DOM elements (`el('id')`) and server data properties (e.g., `serverData.data?.board`, `serverData.goTime`) to prevent reference errors.
   - Ensured `state.currentMatch` and related properties exist before access.

3. **Snapshot Listener Cleanup**:
   - Properly unsubscribe from `unsubscribeMatches` and `unsubscribeActiveMatches` in `concludeMatchUI` and `resetBtn` handler to prevent memory leaks.
   - Store unsubscribe functions in arrays for multiple listeners.

4. **Async Error Handling**:
   - Wrapped all Firestore operations (`updateDoc`, `setDoc`, `addDoc`, `getDoc`, `deleteDoc`) in try-catch blocks to log errors and update UI status.

5. **Data Consistency**:
   - Renamed `challenges` collection to `matches` for clarity.
   - Store math sprint answers in Firestore to ensure server-side validation.
   - Added early click detection in reaction game (`clicks[role] && !goTime`).

6. **Initialization Checks**:
   - Added null checks in `init` and other functions to ensure DOM elements and state variables are available.

7. **Match Resolution**:
   - Moved resolution logic to snapshot handlers to prevent race conditions.
   - Ensured only one player updates match status to `finished` to avoid conflicts.

### Firestore Security Rules Recommendation
To ensure the app works without authentication, your Firestore security rules should allow anonymous access to the `matches` and `users` collections, as shown above. If rules are more restrictive, you may encounter "Permission denied" errors. Update your Firebase console with the above rules or ensure your app has proper write permissions for unauthenticated users.

### Potential Console Errors Addressed
- **Permission Denied**: Added try-catch blocks and proper security rules.
- **Cannot read property 'X' of undefined/null**: Added null checks for DOM elements and Firestore data.
- **Maximum update depth exceeded**: Ensured single updates in match resolution logic.
- **Listener already exists**: Cleaned up listeners in `concludeMatchUI` and `resetBtn` handlers.
- **Firestore timeout/network errors**: Added error handling with user feedback via `setStatus`.

### Testing Recommendations
- **Test Firestore Rules**: Use the Firebase Emulator Suite to simulate security rules and catch permission issues.
- **Simulate Network Issues**: Test with network throttling to ensure timeout handling works.
- **Check DOM Loading**: Load the page before DOMContentLoaded to catch missing element errors.
- **Multiplayer Testing**: Use multiple browser instances with different `userId`s to simulate real-time interactions.

This revised code should minimize console errors while maintaining real-time multiplayer functionality. If specific errors persist, please share the exact console error messages, and I can provide targeted fixes.
