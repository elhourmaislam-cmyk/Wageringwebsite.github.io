let socket = null;
</style>
</head>
<body>
<div class="login-container" id="loginScreen">
  <div class="login-panel" id="authPanel">
    <h2 id="authTitle">Login to Challenge Arena</h2>
    <div id="loginForm">
      <input id="loginUsername" class="login-input" type="text" placeholder="Username" />
      <input id="loginPassword" class="login-input" type="password" placeholder="Password" />
      <button class="primary login-btn" id="loginBtn">Login</button>
      <div class="small muted toggle-btn" id="showSignup">Need an account? Sign Up</div>
    </div>
    <div id="signupForm" style="display: none;">
      <input id="signupUsername" class="login-input" type="text" placeholder="Username" />
      <input id="signupPassword" class="login-input" type="password" placeholder="Password" />
      <input id="signupConfirmPassword" class="login-input" type="password" placeholder="Confirm Password" />
      <button class="primary login-btn" id="signupBtn">Sign Up</button>
      <div class="small muted toggle-btn" id="showLogin">Already have an account? Login</div>
    </div>
    <div id="authError" class="small muted" style="margin-top: 8px;"></div>
  </div>
</div>
<div class="container" id="gameScreen" style="display: none;">
  <div class="topbar">
    <div class="title">üí† Challenge Arena</div>
    <div class="global-controls">
      <button class="primary small" id="logoutBtn">Logout</button>
    </div>
  </div>
  <header>
    <h2 id="playerName">Player</h2>
    <div class="balance">Tokens: <span id="bal1">100</span></div>
  </header>
  <div class="panel">
    <div class="small muted center">Game Selection</div>
    <div class="game-menu" id="menu1">
      <div class="game-option active" data-game="reaction">‚ö° Reaction Duel</div>
      <div class="game-option" data-game="math">üßÆ Math Sprint</div>
      <div class="game-option" data-game="ttt">‚ùå‚≠ï Tic Tac Toe</div>
    </div>
    <div class="small muted center" style="margin-top:12px">Stake Amount</div>
    <div class="controls">
      <input id="stake1" class="stake-input" type="number" value="10" min="1" />
      <div class="muted">Tokens</div>
    </div>
    <div class="controls">
      <button class="primary ready-btn" id="create1">Create Challenge</button>
    </div>
    <div class="board-area" id="area1"></div>
    <div class="status" id="status1">Not Ready</div>
  </div>
</div>
<script>
// Attempt to connect to socket.io server if available. If not, fall back to localStorage sync.
let socket = null;
// Optional Supabase realtime DB (for GitHub Pages compatibility).
// To enable: create a Supabase project, create table `open_wagers` with columns (id text primary key, proposer text, game text, stake int, createdAt timestamptz)
// then set SUPABASE_URL and SUPABASE_ANON_KEY below (or set them via a build process/environment).
let supabase = null;
const SUPABASE_URL = ''; // e.g. https://xyzcompany.supabase.co
const SUPABASE_ANON_KEY = ''; // your anon/public key

async function tryConnectSupabase() {
  if (!SUPABASE_URL || !SUPABASE_ANON_KEY) return;
  try {
    const mod = await import('https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm');
    const { createClient } = mod;
    supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    await fetchWagersFromSupabase();
    subscribeWagersFromSupabase();
    console.log('Connected to Supabase');
  } catch (err) {
    console.warn('Supabase connect failed', err);
    supabase = null;
  }
}

async function fetchWagersFromSupabase() {
  if (!supabase) return;
  try {
    const { data, error } = await supabase
      .from('open_wagers')
      .select('*')
      .order('createdAt', { ascending: true });
    if (error) { console.warn('supabase fetch error', error); return; }
    state.wagers = data || [];
    // update local cache for non-supabase clients
    try { localStorage.setItem('openWagers', JSON.stringify(state.wagers)); } catch (e) {}
    if (state.loggedIn && !state.ongoing) renderAreas();
  } catch (e) { console.warn(e); }
}

function subscribeWagersFromSupabase() {
  if (!supabase) return;
  try {
    const channel = supabase.channel('public:open_wagers');
    channel.on('postgres_changes', { event: '*', schema: 'public', table: 'open_wagers' }, payload => {
      // Re-fetch the list for simplicity (diffs could be applied from payload)
      fetchWagersFromSupabase();
    });
    channel.subscribe();
  } catch (e) { console.warn('supabase subscribe error', e); }
}
function tryConnectSocket() {
  try {
    // load socket.io client script dynamically from same server
    const s = document.createElement('script');
    s.src = '/socket.io/socket.io.js';
    s.onload = () => {
      socket = io();
      setupSocketHandlers();
    };
    s.onerror = () => { socket = null; };
    document.head.appendChild(s);
  } catch (e) {
    socket = null;
  }
}

function setupSocketHandlers() {
  if (!socket) return;
  socket.on('connect', () => {
    console.log('connected to socket server', socket.id);
  });
  socket.on('wagers', (wagers) => {
    // replace local wagers with server state
    state.wagers = Array.isArray(wagers) ? wagers : [];
    // update localStorage cache for clients without socket
    try { localStorage.setItem('openWagers', JSON.stringify(state.wagers)); } catch(e) {}
    if (state.loggedIn && !state.ongoing) renderAreas();
  });
  socket.on('acceptSuccess', (data) => {
    // data: { id, wager }
    // The accepter should start a match locally
    if (data && data.wager) startMatch(data.wager.game, data.wager.stake);
  });
  socket.on('acceptFailed', (data) => {
    alert('Accept failed: ' + (data && data.reason));
    // refresh local state
    if (state.loggedIn && !state.ongoing) renderAreas();
  });
}
/* ====== State ====== */
const state = {
  loggedIn: false,
  username: '',
  balance: 100,
  selectedGame: 'reaction',
  ongoing: false,
  currentMatch: null,
  wagers: []
};

/* ====== Helpers ====== */
const el = id => document.getElementById(id);
function setStatus(txt) { el('status1').textContent = txt; }
function updateBalance() { el('bal1').textContent = state.balance; }

/* ====== User Storage ====== */
function loadUsers() {
  return JSON.parse(localStorage.getItem('users') || '{}');
}

function saveUsers(users) {
  localStorage.setItem('users', JSON.stringify(users));
}

function loadUserBalance(username) {
  const balances = JSON.parse(localStorage.getItem('userBalances') || '{}');
  return balances[username] || 100; // Default balance
}

function saveUserBalance(username, balance) {
  const balances = JSON.parse(localStorage.getItem('userBalances') || '{}');
  balances[username] = balance;
  localStorage.setItem('userBalances', JSON.stringify(balances));
}

/* ====== Cross-tab Wager / Match Storage ====== */
function loadOpenWagers() {
  try {
    return JSON.parse(localStorage.getItem('openWagers') || '[]');
  } catch (e) { return []; }
}

function saveOpenWagers(wagers) {
  localStorage.setItem('openWagers', JSON.stringify(wagers));
}

function loadActiveMatches() {
  try {
    return JSON.parse(localStorage.getItem('activeMatches') || '[]');
  } catch (e) { return []; }
}

function saveActiveMatches(matches) {
  localStorage.setItem('activeMatches', JSON.stringify(matches));
}

function setCurrentUser(username) {
  if (username) localStorage.setItem('currentUser', username);
  else localStorage.removeItem('currentUser');
}

function getCurrentUser() {
  return localStorage.getItem('currentUser');
}

/* ====== Auth System ====== */
function setupAuth() {
  // Initialize users if none exist (for testing)
  const users = loadUsers();
  if (Object.keys(users).length === 0) {
    users['admin'] = 'password123'; // Default user
    saveUsers(users);
  }

  // Toggle between login and signup
  el('showSignup').addEventListener('click', () => {
    el('loginForm').style.display = 'none';
    el('signupForm').style.display = 'block';
    el('authTitle').textContent = 'Sign Up for Challenge Arena';
    el('authError').textContent = '';
    el('loginUsername').value = '';
    el('loginPassword').value = '';
  });

  el('showLogin').addEventListener('click', () => {
    el('signupForm').style.display = 'none';
    el('loginForm').style.display = 'block';
    el('authTitle').textContent = 'Login to Challenge Arena';
    el('authError').textContent = '';
    el('signupUsername').value = '';
    el('signupPassword').value = '';
    el('signupConfirmPassword').value = '';
  });

  // Login
  el('loginBtn').addEventListener('click', () => {
    const username = el('loginUsername').value.trim();
    const password = el('loginPassword').value.trim();
    const users = loadUsers();
    if (users[username] && users[username] === password) {
      state.loggedIn = true;
      state.username = username;
      state.balance = loadUserBalance(username);
      setCurrentUser(username);
      showGameScreen();
    } else {
      el('authError').textContent = 'Invalid username or password.';
    }
  });

  // Sign Up
  el('signupBtn').addEventListener('click', () => {
    const username = el('signupUsername').value.trim();
    const password = el('signupPassword').value.trim();
    const confirmPassword = el('signupConfirmPassword').value.trim();
    const users = loadUsers();

    if (!username || !password || !confirmPassword) {
      el('authError').textContent = 'All fields are required.';
      return;
    }
    if (password !== confirmPassword) {
      el('authError').textContent = 'Passwords do not match.';
      return;
    }
    if (users[username]) {
      el('authError').textContent = 'Username already taken.';
      return;
    }

    users[username] = password;
    saveUsers(users);
    saveUserBalance(username, 100); // Initial balance
    el('authError').textContent = 'Sign-up successful! Please log in.';
    el('showLogin').click(); // Switch to login form
  });

  // Logout
  el('logoutBtn').addEventListener('click', () => {
    saveUserBalance(state.username, state.balance);
    state.loggedIn = false;
    state.username = '';
    state.balance = 100;
    state.wagers = [];
    state.ongoing = false;
    state.currentMatch = null;
    setCurrentUser(null);
    el('gameScreen').style.display = 'none';
    el('loginScreen').style.display = 'flex';
    el('loginUsername').value = '';
    el('loginPassword').value = '';
    el('signupUsername').value = '';
    el('signupPassword').value = '';
    el('signupConfirmPassword').value = '';
    el('authError').textContent = '';
    setStatus('Not Ready');
  });
}

function showGameScreen() {
  el('loginScreen').style.display = 'none';
  el('gameScreen').style.display = 'flex';
  el('playerName').textContent = state.username;
  updateBalance();
  // load open wagers from storage
  state.wagers = loadOpenWagers();
  renderAreas();
}

/* ====== Menu Selection ====== */
function setupMenus() {
  const menu = el('menu1');
  menu.addEventListener('click', e => {
    const opt = e.target.closest('.game-option');
    if (!opt) return;
    menu.querySelectorAll('.game-option').forEach(o => o.classList.remove('active'));
    opt.classList.add('active');
    state.selectedGame = opt.dataset.game;
    setStatus('Selected: ' + opt.textContent.trim());
  });
}

/* ====== Wager Buttons ====== */
function setupWagers() {
  el('create1').addEventListener('click', () => createWager());
  el('area1').addEventListener('click', e => handleWagerClick(e));
}

/* ====== Create Wager ====== */
function createWager() {
  if (state.ongoing) return;
  const stake = Number(el('stake1').value) || 1;
  if (stake < 1) {
    alert("Stake must be at least 1.");
    return;
  }
  if (state.balance < stake) {
    alert("Not enough Tokens to stake.");
    return;
  }
  const game = state.selectedGame;
  // Assign a unique id so we can track this specific wager across timeouts
  const wid = Date.now() + '-' + Math.random().toString(36).slice(2,8);
  const newWager = { id: wid, proposer: state.username, game, stake, createdAt: Date.now(), accepted: false };
  if (socket && socket.connected) {
    socket.emit('createWager', newWager);
  } else {
    // Persist to shared storage so other tabs see it
    const open = loadOpenWagers();
    open.push(newWager);
    saveOpenWagers(open);
    state.wagers = open;
  }
  setStatus('Wager created. Waiting for opponent...');
  renderAreas();
  // Simulate bot opponent: only accept after 30s and only if this wager
  // still exists and hasn't been accepted by another player.
  setTimeout(() => {
    // Bot acceptance only if still open
    const openNow = loadOpenWagers();
    const wager = openNow.find(w => w.id === wid);
    if (wager && !wager.accepted) {
      // If connected to server, let server handle removal and notify clients
      if (socket && socket.connected) {
        socket.emit('cancelWager', wid);
      } else {
        // Remove this wager from shared storage
        const remaining = openNow.filter(w => w.id !== wid);
        saveOpenWagers(remaining);
        state.wagers = remaining;
        renderAreas();
        // Bot accepts
        startMatch(wager.game, wager.stake, { opponentIsBot: true });
      }
    }
  }, 30000);
}

/* ====== Handle Wager Click ====== */
function handleWagerClick(e) {
  const cancel = e.target.closest('.cancel-btn');
  if (!state.ongoing) {
    // Cancel button (only proposer can cancel)
    if (cancel) {
      const idx = Number(cancel.dataset.idx);
      const w = state.wagers[idx];
      if (w && w.proposer === state.username) {
        // Cancel: prefer supabase, then server, then localStorage
        if (supabase) {
          supabase.from('open_wagers').delete().eq('id', w.id).then(() => {
            // subscription will refresh
          }).catch(e => console.warn('supabase delete error', e));
        } else if (socket && socket.connected) {
          socket.emit('cancelWager', w.id);
        } else {
          const openNow = loadOpenWagers();
          const remaining = openNow.filter(item => item.id !== w.id);
          saveOpenWagers(remaining);
          state.wagers = remaining;
          renderAreas();
          setStatus('Wager cancelled.');
        }
      } else {
        alert("Cannot cancel this wager.");
      }
      return;
    }
    // Accept button (other players can accept)
    const accept = e.target.closest('.accept-btn');
    if (accept) {
      const idx = Number(accept.dataset.idx);
      const w = state.wagers[idx];
      if (!w) return;
      if (w.proposer === state.username) { alert('You cannot accept your own wager.'); return; }
      // Atomically remove from storage and start match
      const openNow = loadOpenWagers();
      if (socket && socket.connected) {
        socket.emit('acceptWager', w.id);
        // server will reply with acceptSuccess/acceptFailed
      } else {
        const found = openNow.find(item => item.id === w.id);
        if (!found) { alert('This wager was taken or cancelled.'); renderAreas(); return; }
        const remaining = openNow.filter(item => item.id !== w.id);
        saveOpenWagers(remaining);
        state.wagers = remaining;
        renderAreas();
        startMatch(w.game, w.stake);
      }
      return;
    }
  }
}

/* ====== Render Areas with Wagers ====== */
function renderAreas() {
  if (state.ongoing) return;
  const areaEl = el('area1');
  areaEl.innerHTML = '';
  // Ensure we always show the latest shared wagers
  state.wagers = loadOpenWagers();
  if (state.wagers.length === 0) {
    areaEl.innerHTML = '<div class="center muted">No open challenges. Create one!</div>';
    return;
  }
  state.wagers.forEach((w, idx) => {
    const box = document.createElement('div');
    box.className = 'panel';
    box.style.marginBottom = '12px';
    // Show cancel button only to proposer, otherwise show Accept button
    let actionBtn = '';
    if (w.proposer === state.username) {
      actionBtn = `<button class="primary cancel-btn" data-idx="${idx}" style="background:#ff6b6b;color:#fff">Cancel</button>`;
    } else {
      actionBtn = `<button class="primary accept-btn" data-idx="${idx}" style="background:#4caf50;color:#fff">Accept</button>`;
    }
    box.innerHTML = `
      <div>Challenger: ${w.proposer}</div>
      <div>Game: ${prettyGameName(w.game)}</div>
      <div>Stake: ${w.stake} tokens</div>
      <div class="controls" style="justify-content: space-around">
        ${actionBtn}
      </div>`;
    areaEl.appendChild(box);
  });
}

/* ====== Match Lifecycle ====== */
function startMatch(game, stake, opts = {}) {
  const opponentIsBot = !!opts.opponentIsBot;
  state.ongoing = true;
  state.currentMatch = { game, stake, startedAt: Date.now(), opponentIsBot };
  state.balance -= stake;
  updateBalance();
  setStatus('Match starting: ' + prettyGameName(game));
  renderGameUI(game);
}

/* ====== Rendering per-game UI ====== */
function prettyGameName(k) {
  return ({ reaction: 'Reaction Duel', math: 'Math Sprint', ttt: 'Tic Tac Toe' })[k] || k;
}

function renderGameUI(game) {
  el('area1').innerHTML = '';
  if (game === 'reaction') renderReaction();
  else if (game === 'math') renderMathSprint();
  else if (game === 'ttt') renderTicTacToe();
}

/* ====== Reaction Duel ====== */
function renderReaction() {
  const area = el('area1');
  const box = document.createElement('div');
  box.className = 'go-box center';
  box.style.width = '100%';
  const text = document.createElement('div');
  text.className = 'countdown';
  text.textContent = 'Get Ready...';
  const btn = document.createElement('button');
  btn.className = 'large-btn';
  btn.textContent = 'PRESS';
  btn.disabled = true;
  box.append(text, document.createElement('br'), btn);
  area.appendChild(box);
  let go = false, resolved = false;
  // Bot reaction helpers
  let botReacted = false;
  let botTimeoutId = null;
  btn.addEventListener('click', () => handleClick());
  function handleClick() {
    if (resolved) return;
    if (!go) {
      resolved = true;
      finalizeMatch(false, 'Clicked early (foul).');
      return;
    }
    resolved = true;
    const playerTime = Date.now() - state.currentMatch.startedAt;
    const opponentIsBot = state.currentMatch && state.currentMatch.opponentIsBot;
    if (opponentIsBot) {
      // If bot already reacted, player loses
      if (botReacted) { finalizeMatch(false, 'Bot reacted faster!'); return; }
      // Otherwise simulate bot time
      const opponentTime = (botTimeoutId ? (Date.now() - state.currentMatch.startedAt) : playerTime + Math.random() * 500 - 250);
      if (playerTime < opponentTime) finalizeMatch(true, 'You reacted faster!');
      else finalizeMatch(false, 'Bot reacted faster!');
      if (botTimeoutId) clearTimeout(botTimeoutId);
    } else {
      const opponentTime = playerTime + Math.random() * 500 - 250; // Simulate opponent
      if (playerTime < opponentTime) finalizeMatch(true, 'You reacted faster!');
      else finalizeMatch(false, 'Opponent reacted faster!');
    }
  }
  const delay = 1200 + Math.floor(Math.random() * 2000);
  setTimeout(() => {
    go = true;
    text.textContent = 'GO!';
    btn.disabled = false;
    // Schedule bot reaction when GO appears
    if (state.currentMatch && state.currentMatch.opponentIsBot) {
      const botDelay = 200 + Math.floor(Math.random() * 400); // 200 - 600ms
      botTimeoutId = setTimeout(() => {
        if (resolved) return;
        botReacted = true;
        resolved = true;
        finalizeMatch(false, 'Bot reacted faster!');
      }, botDelay);
    }
  }, delay);
  setTimeout(() => {
    if (!resolved) {
      resolved = true;
      finalizeMatch(false, 'No one reacted in time.');
    }
  }, 8000);
}

/* ====== Math Sprint ====== */
function renderMathSprint() {
  const area = el('area1');
  const problem = generateMathProblem();
  const box = document.createElement('div');
  box.style.width = '100%';
  box.innerHTML = `
    <div style="font-weight:700;margin-bottom:8px">Solve:</div>
    <div class="go-box" style="margin-bottom:8px"><div style="font-size:22px">${problem.question}</div></div>
    <input id="input1" type="number" class="stake-input" placeholder="Your answer" />
    <div style="margin-top:8px"><button id="submit1" class="primary">Submit</button></div>
    <div id="msg1" class="small muted" style="margin-top:8px"></div>`;
  area.appendChild(box);
  let resolved = false;
  const startTime = Date.now();
  // Bot answering state
  let botAnswered = false;
  let botAnswer = null;
  const submit = el('submit1');
  const inp = el('input1');
  submit.addEventListener('click', () => handleSubmit(inp.value));
  function handleSubmit(value) {
    if (resolved) return;
    const numeric = Number(value);
    const msg = el('msg1');
    if (isNaN(numeric)) { msg.textContent = 'Enter a number.'; return; }
    const correct = numeric === problem.answer;
    const time = Date.now() - startTime;
    msg.textContent = correct ? `Correct! (${time} ms)` : `Wrong (${time} ms)`;
    if (correct) {
      resolved = true;
      const opponentIsBot = state.currentMatch && state.currentMatch.opponentIsBot;
      if (opponentIsBot) {
        // If bot answered correctly earlier, player loses
        if (botAnswered && botAnswer && botAnswer.correct) {
          finalizeMatch(false, 'Bot answered first!');
          return;
        }
        const opponentTime = botAnswered && botAnswer ? botAnswer.time : (time + Math.random() * 1000 - 500);
        if (time < opponentTime) finalizeMatch(true, `Answered correctly in ${time} ms`);
        else finalizeMatch(false, 'Bot answered faster!');
      } else {
        const opponentTime = time + Math.random() * 1000 - 500;
        if (time < opponentTime) finalizeMatch(true, `Answered correctly in ${time} ms`);
        else finalizeMatch(false, 'Opponent answered faster!');
      }
    } else {
      resolved = true;
      const d1 = Math.abs(numeric - problem.answer);
      const d2 = Math.abs((Math.random() * 20 - 10) - problem.answer); // Simulate opponent
      if (d1 < d2) finalizeMatch(true, 'Both wrong, but you were closer!');
      else finalizeMatch(false, 'Both wrong, opponent was closer!');
    }
  }
  // If opponent is bot, schedule its answer
  if (state.currentMatch && state.currentMatch.opponentIsBot) {
    const willBeCorrect = Math.random() < 0.8; // 80% chance to be correct
    const botDelay = 400 + Math.floor(Math.random() * 1600); // 400-2000ms
    setTimeout(() => {
      if (resolved) return;
      botAnswered = true;
      botAnswer = { correct: willBeCorrect, time: Date.now() - startTime };
      if (willBeCorrect) {
        resolved = true;
        finalizeMatch(false, 'Bot answered correctly first!');
      }
    }, botDelay);
  }
  setTimeout(() => {
    if (!resolved) {
      resolved = true;
      const v1 = Number(el('input1').value);
      const d1 = isNaN(v1) ? Infinity : Math.abs(v1 - problem.answer);
      const d2 = Math.abs((Math.random() * 20 - 10) - problem.answer);
      if (d1 === d2) finalizeDraw('No decisive answer ‚Äî draw');
      else finalizeMatch(d1 < d2, 'Time end ‚Äî closer answer wins');
    }
  }, 10000);
}

function generateMathProblem() {
  const ops = ['+', '-', '*'];
  const op = ops[Math.floor(Math.random() * ops.length)];
  let a = Math.floor(Math.random() * 12) + 1;
  let b = Math.floor(Math.random() * 12) + 1;
  if (op === '-' && b > a) { [a, b] = [b, a]; }
  const question = `${a} ${op} ${b}`;
  let answer;
  if (op === '+') answer = a + b;
  if (op === '-') answer = a - b;
  if (op === '*') answer = a * b;
  return { question, answer };
}

/* ====== Tic Tac Toe ====== */
function renderTicTacToe() {
  const area = el('area1');
  const board = document.createElement('div');
  board.style.width = '100%';
  board.className = 'center';
  const grid = document.createElement('div');
  grid.className = 'ttt-grid';
  const cells = [];
  for (let i = 0; i < 9; i++) {
    const c = document.createElement('div');
    c.className = 'ttt-cell';
    c.dataset.idx = i;
    c.addEventListener('click', () => tttClick(i));
    cells.push(c);
    grid.appendChild(c);
  }
  board.appendChild(grid);
  area.appendChild(board);
  let gameBoard = Array(9).fill(null);
  let current = 1; // Player is X, opponent is O
  setStatus('TicTacToe ‚Äî Your turn (X)');
  function syncRender() {
    cells.forEach((cell, i) => {
      cell.textContent = gameBoard[i] === 1 ? 'X' : gameBoard[i] === 2 ? 'O' : '';
    });
  }
  function tttClick(i) {
    if (gameBoard[i] !== null || current !== 1 || state.ongoing === false) return;
    gameBoard[i] = 1;
    syncRender();
    const winner = checkTTTWinner(gameBoard);
    if (winner) {
      finalizeMatch(winner === 1, `TicTacToe ‚Äî ${winner === 1 ? 'You win' : 'Opponent wins'}`);
      return;
    }
    if (gameBoard.every(v => v !== null)) {
      finalizeDraw('TicTacToe ‚Äî Draw');
      return;
    }
    current = 2;
    setStatus('TicTacToe ‚Äî Opponent\'s turn (O)');
    // Simulate opponent move
    setTimeout(() => {
      const available = gameBoard.map((v, i) => v === null ? i : null).filter(v => v !== null);
      if (available.length > 0) {
        const opponentIsBot = state.currentMatch && state.currentMatch.opponentIsBot;
        let move;
        if (opponentIsBot) move = tttBotChooseMove(gameBoard, 2, 1);
        else move = available[Math.floor(Math.random() * available.length)];
        gameBoard[move] = 2;
        syncRender();
        const winner = checkTTTWinner(gameBoard);
        if (winner) {
          finalizeMatch(winner === 1, `TicTacToe ‚Äî ${winner === 1 ? 'You win' : 'Opponent wins'}`);
          return;
        }
        if (gameBoard.every(v => v !== null)) {
          finalizeDraw('TicTacToe ‚Äî Draw');
          return;
        }
        current = 1;
        setStatus('TicTacToe ‚Äî Your turn (X)');
      }
    }, 500);
  }
  function checkTTTWinner(b) {
    const lines = [ [0,1,2], [3,4,5], [6,7,8], [0,3,6], [1,4,7], [2,5,8], [0,4,8], [2,4,6] ];
    for (const [a, b2, c] of lines) {
      if (b[a] && b[a] === b[b2] && b[a] === b[c]) return b[a];
    }
    return null;
  }

  // Simple TTT bot: try to win, block player, take center, take corners, else random
  function tttBotChooseMove(board, myMark = 2, oppMark = 1) {
    const lines = [ [0,1,2], [3,4,5], [6,7,8], [0,3,6], [1,4,7], [2,5,8], [0,4,8], [2,4,6] ];
    // helper to find winning/blocking move
    for (const mark of [myMark, oppMark]) {
      for (const [a,b,c] of lines) {
        const vals = [board[a], board[b], board[c]];
        const empties = [a,b,c].filter(i => board[i] === null);
        const countMark = vals.filter(v => v === mark).length;
        if (countMark === 2 && empties.length === 1) return empties[0];
      }
    }
    // center
    if (board[4] === null) return 4;
    // corners
    const corners = [0,2,6,8].filter(i => board[i] === null);
    if (corners.length > 0) return corners[Math.floor(Math.random() * corners.length)];
    // fallback: any empty
    const empties = board.map((v,i) => v === null ? i : null).filter(v => v !== null);
    return empties[Math.floor(Math.random() * empties.length)];
  }
}

/* ====== Finalize Match Results ====== */
function finalizeMatch(won, reason = '') {
  const stake = state.currentMatch.stake;
  if (won) state.balance += stake * 2;
  updateBalance();
  if (won) el('area1').parentElement.classList.add('glow-win');
  concludeMatchUI(won ? `You win! ${reason}` : `Opponent wins! ${reason}`);
}

function finalizeDraw(reason = '') {
  const stake = state.currentMatch.stake;
  state.balance += stake;
  updateBalance();
  concludeMatchUI('Draw! ' + reason);
}

function concludeMatchUI(message) {
  state.ongoing = false;
  state.currentMatch = null;
  setStatus(message);
  setTimeout(() => {
    el('area1').innerHTML = '';
    renderAreas();
    el('area1').parentElement.classList.remove('glow-win');
  }, 1600);
}

/* ====== Init ====== */
setupAuth();
setupMenus();
setupWagers();
updateBalance();

// Initialize state from storage: persistent login and wagers
const preUser = getCurrentUser();
if (preUser) {
  // restore session
  state.loggedIn = true;
  state.username = preUser;
  state.balance = loadUserBalance(preUser) || 100;
  showGameScreen();
}

// ensure wagers array is in sync on load
state.wagers = loadOpenWagers();
// Auto-refresh: periodically sync from storage (keeps wagers & balance up-to-date)
let __autoRefreshTimer = null;
function syncFromStorage() {
  // sync wagers
  const open = loadOpenWagers();
  if (JSON.stringify(open) !== JSON.stringify(state.wagers)) {
    state.wagers = open;
    if (state.loggedIn && !state.ongoing) renderAreas();
  }
  // sync balance for the current user (in case another tab updated it)
  if (state.loggedIn && state.username) {
    const bal = loadUserBalance(state.username) || 100;
    if (bal !== state.balance) { state.balance = bal; updateBalance(); }
  }
}

function startAutoRefresh(intervalMs = 3000) {
  if (__autoRefreshTimer) return;
  __autoRefreshTimer = setInterval(syncFromStorage, intervalMs);
}

function stopAutoRefresh() {
  if (!__autoRefreshTimer) return;
  clearInterval(__autoRefreshTimer);
  __autoRefreshTimer = null;
}

// Pause polling when page is hidden to save CPU
document.addEventListener('visibilitychange', () => {
  if (document.hidden) stopAutoRefresh(); else startAutoRefresh();
});

// start polling immediately
startAutoRefresh();

// Try to connect to socket server (if the server is running alongside the site)
tryConnectSocket();

// Cross-tab updates: listen for storage changes to openWagers or currentUser
window.addEventListener('storage', (e) => {
  if (e.key === 'openWagers') {
    state.wagers = loadOpenWagers();
    // If on game screen and not in a match, re-render
    if (state.loggedIn && !state.ongoing) renderAreas();
  }
  if (e.key === 'currentUser') {
    const cu = getCurrentUser();
    if (!cu) {
      // logged out elsewhere
      if (state.loggedIn) {
        // Save current balance and force logout
        saveUserBalance(state.username, state.balance);
        state.loggedIn = false;
        state.username = '';
        el('gameScreen').style.display = 'none';
        el('loginScreen').style.display = 'flex';
      }
    }
    // If someone logged in on another tab as this user, nothing to change here
  }
});
</script>
</body>
</html>
