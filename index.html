<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Challenge Arena ‚Äî Tokens</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #050507;
  --panel: #0f1113;
  --accent1: #00ffff;
  --accent2: #7cff66;
  --glass: rgba(255,255,255,0.03);
}
* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; font-family: 'Poppins', sans-serif; background: radial-gradient(1200px 600px at 10% 10%, rgba(0,255,204,0.03), transparent), linear-gradient(180deg,#030304 0%, #07070a 100%); color: #eafcff; }
.container { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; padding: 24px; }
.panel { width: 100%; max-width: 500px; background: var(--panel); border-radius: 12px; padding: 14px; box-shadow: 0 6px 28px rgba(2,8,12,0.6), inset 0 0 30px rgba(0,255,204,0.02); border: 1px solid rgba(0,255,204,0.06); }
header { width: 100%; text-align: center; margin-bottom: 12px; }
h2 { margin: 6px 0; font-size: 20px; letter-spacing: 1px; }
.balance { margin: 6px 0; color: var(--accent2); font-weight: 600; }
button.primary { margin-top: 10px; padding: 10px 14px; border-radius: 10px; border: none; font-weight: 700; cursor: pointer; background: linear-gradient(90deg, var(--accent1), var(--accent2)); color: #001; box-shadow: 0 6px 18px rgba(0,255,204,0.08); }
.muted { color: #9fb8b2; font-size: 13px; }
.controls { display: flex; gap: 10px; margin-top: 10px; align-items: center; justify-content: center; }
.stake-input { width: 110px; padding: 8px; border-radius: 8px; border: 1px solid rgba(0,255,204,0.08); background: #050607; color: var(--accent1); font-weight: 600; text-align: center; }
.game-menu { display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap; justify-content: center; }
.game-option { padding: 8px 10px; border-radius: 10px; background: var(--glass); border: 1px solid rgba(255,255,255,0.02); cursor: pointer; font-weight: 600; }
.game-option.active { box-shadow: 0 8px 28px rgba(0,255,204,0.06); border: 1px solid rgba(0,255,204,0.12); }
.board-area { margin-top: 14px; width: 100%; display: flex; justify-content: center; align-items: center; min-height: 220px; flex-direction: column; }
.status { margin-top: 10px; font-weight: 600; color: #cde; text-align: center; }
.ready-btn { width: 120px; }
.large-btn { padding: 18px 22px; font-size: 18px; border-radius: 12px; background: linear-gradient(90deg, var(--accent1), var(--accent2)); color: #001; border: none; cursor: pointer; }
.go-box { padding: 22px 18px; border-radius: 12px; background: #020304; border: 1px solid rgba(0,255,204,0.06); }
.countdown { font-size: 28px; font-weight: 700; letter-spacing: 2px; }
.ttt-grid { display: grid; grid-template-columns: repeat(3, 80px); gap: 8px; justify-content: center; }
.ttt-cell { width: 80px; height: 80px; border-radius: 10px; background: #080a0b; display: flex; align-items: center; justify-content: center; font-size: 34px; cursor: pointer; border: 1px solid rgba(0,255,204,0.03); }
.ttt-cell:hover { transform: translateY(-3px); }
.topbar { position: fixed; top: 14px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; align-items: center; z-index: 30; }
.title { font-size: 20px; font-weight: 700; background: linear-gradient(90deg, var(--accent1), var(--accent2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.global-controls { display: flex; gap: 8px; align-items: center; background: rgba(0,0,0,0.45); padding: 8px 12px; border-radius: 12px; border: 1px solid rgba(0,255,204,0.04); }
.small { font-size: 13px; color: #9fc9c2; }
.glow-win { box-shadow: 0 0 30px rgba(124,255,102,0.12), 0 0 80px rgba(0,255,204,0.03); }
.center { display: flex; align-items: center; justify-content: center; }
.login-container { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
.login-panel { background: var(--panel); padding: 20px; border-radius: 12px; width: 300px; text-align: center; }
.login-input { width: 100%; padding: 8px; margin: 8px 0; border-radius: 8px; border: 1px solid rgba(0,255,204,0.08); background: #050607; color: var(--accent1); }
.login-btn { width: 100%; }
.toggle-btn { cursor: pointer; color: var(--accent1); text-decoration: underline; margin-top: 10px; }
</style>
</head>
<body>
<div class="login-container" id="loginScreen">
  <div class="login-panel" id="authPanel">
    <h2 id="authTitle">Login to Challenge Arena</h2>
    <div id="loginForm">
      <input id="loginUsername" class="login-input" type="text" placeholder="Username" />
      <input id="loginPassword" class="login-input" type="password" placeholder="Password" />
      <button class="primary login-btn" id="loginBtn">Login</button>
      <div class="small muted toggle-btn" id="showSignup">Need an account? Sign Up</div>
    </div>
    <div id="signupForm" style="display: none;">
      <input id="signupUsername" class="login-input" type="text" placeholder="Username" />
      <input id="signupPassword" class="login-input" type="password" placeholder="Password" />
      <input id="signupConfirmPassword" class="login-input" type="password" placeholder="Confirm Password" />
      <button class="primary login-btn" id="signupBtn">Sign Up</button>
      <div class="small muted toggle-btn" id="showLogin">Already have an account? Login</div>
    </div>
    <div id="authError" class="small muted" style="margin-top: 8px;"></div>
  </div>
</div>
<div class="container" id="gameScreen" style="display: none;">
  <div class="topbar">
    <div class="title">üí† Challenge Arena</div>
    <div class="global-controls">
      <button class="primary small" id="logoutBtn">Logout</button>
    </div>
  </div>
  <header>
    <h2 id="playerName">Player</h2>
    <div class="balance">Tokens: <span id="bal1">100</span></div>
  </header>
  <div class="panel">
    <div class="small muted center">Game Selection</div>
    <div class="game-menu" id="menu1">
      <div class="game-option active" data-game="reaction">‚ö° Reaction Duel</div>
      <div class="game-option" data-game="math">üßÆ Math Sprint</div>
      <div class="game-option" data-game="ttt">‚ùå‚≠ï Tic Tac Toe</div>
    </div>
    <div class="small muted center" style="margin-top:12px">Stake Amount</div>
    <div class="controls">
      <input id="stake1" class="stake-input" type="number" value="10" min="1" />
      <div class="muted">Tokens</div>
    </div>
    <div class="controls">
      <button class="primary ready-btn" id="create1">Create Challenge</button>
    </div>
    <div class="board-area" id="area1"></div>
    <div class="status" id="status1">Not Ready</div>
  </div>
</div>
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, collection, addDoc, query, where, orderBy, onSnapshot, serverTimestamp, deleteDoc, disableNetwork } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyCxU57etJTjzv2hCqFFYqQyHEQcoebfsHE",
  authDomain: "wagering-59415.firebaseapp.com",
  projectId: "wagering-59415",
  storageBucket: "wagering-59415.firebasestorage.app",
  messagingSenderId: "1063169096719",
  appId: "1:1063169096719:web:e10a094630347b5fffb77a",
  measurementId: "G-PNND9Q37XQ"
};

// Initialize Firebase and Firestore
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Disable offline persistence to ensure online operations
disableNetwork(db).catch((error) => {
  console.error('Error disabling Firestore offline persistence:', error);
});

// Test Firestore connection
async function testFirestoreConnection() {
  try {
    const testRef = doc(db, 'test', 'ping');
    await setDoc(testRef, { timestamp: Date.now() });
    console.log('Firestore connection test successful');
    return true;
  } catch (error) {
    console.error('Firestore connection test failed:', error, { code: error.code, message: error.message });
    return false;
  }
}
testFirestoreConnection();

/* ====== State ====== */
const state = {
  loggedIn: false,
  username: '',
  balance: 100,
  selectedGame: 'reaction',
  ongoing: false,
  currentMatch: null,
  wagers: [],
  matchListener: null
};

/* ====== Helpers ====== */
const el = id => document.getElementById(id);
function setStatus(txt) { el('status1').textContent = txt; }
function updateBalance() { el('bal1').textContent = state.balance; }
let unsubscribeWagers = null;

// Username validation
function isValidUsername(username) {
  const invalidChars = /[\/\\.#$[\]*]/; // Firestore document ID restrictions
  return username && 
         username.length >= 3 && 
         username.length <= 20 && 
         /^[a-zA-Z0-9_-]+$/.test(username) && 
         !invalidChars.test(username);
}

/* ====== User Balance Update ====== */
async function updateUserBalance() {
  if (!state.username) return;
  try {
    await updateDoc(doc(db, 'users', state.username), { balance: state.balance });
  } catch (error) {
    console.error('Update balance error:', error);
    setStatus('Error updating balance.');
  }
}

/* ====== Auth System ====== */
function setupAuth() {
  el('showSignup').addEventListener('click', () => {
    el('loginForm').style.display = 'none';
    el('signupForm').style.display = 'block';
    el('authTitle').textContent = 'Sign Up for Challenge Arena';
    el('authError').textContent = '';
    el('loginUsername').value = '';
    el('loginPassword').value = '';
  });

  el('showLogin').addEventListener('click', () => {
    el('signupForm').style.display = 'none';
    el('loginForm').style.display = 'block';
    el('authTitle').textContent = 'Login to Challenge Arena';
    el('authError').textContent = '';
    el('signupUsername').value = '';
    el('signupPassword').value = '';
    el('signupConfirmPassword').value = '';
  });

  el('loginBtn').addEventListener('click', async () => {
    if (!navigator.onLine) {
      el('authError').textContent = 'You are offline. Please connect to the internet.';
      return;
    }
    const username = el('loginUsername').value.trim();
    const password = el('loginPassword').value.trim();
    if (!username || !password) {
      el('authError').textContent = 'Username and password are required.';
      return;
    }
    if (!isValidUsername(username)) {
      el('authError').textContent = 'Username must be 3-20 characters, alphanumeric, dashes, or underscores.';
      return;
    }
    try {
      const userRef = doc(db, 'users', username);
      const userSnap = await getDoc(userRef);
      if (userSnap.exists() && userSnap.data().password === password) {
        state.loggedIn = true;
        state.username = username;
        state.balance = userSnap.data().balance || 100;
        el('loginScreen').style.display = 'none';
        el('gameScreen').style.display = 'flex';
        el('playerName').textContent = username;
        updateBalance();
        renderAreas();
        setupWagerListener();
      } else {
        el('authError').textContent = 'Invalid username or password.';
      }
    } catch (error) {
      console.error('Login error:', error, { code: error.code, message: error.message });
      if (error.code === 'unavailable' || error.message.includes('offline')) {
        el('authError').textContent = 'Cannot connect to the server. Please check your internet connection.';
      } else if (error.code === 'permission-denied') {
        el('authError').textContent = 'Permission denied. Contact support.';
      } else {
        el('authError').textContent = `Login error: ${error.message}`;
      }
    }
  });

  el('signupBtn').addEventListener('click', async () => {
    if (!navigator.onLine) {
      el('authError').textContent = 'You are offline. Please connect to the internet.';
      return;
    }
    const username = el('signupUsername').value.trim();
    const password = el('signupPassword').value.trim();
    const confirmPassword = el('signupConfirmPassword').value.trim();
    if (!username || !password || !confirmPassword) {
      el('authError').textContent = 'All fields are required.';
      return;
    }
    if (!isValidUsername(username)) {
      el('authError').textContent = 'Username must be 3-20 characters, alphanumeric, dashes, or underscores.';
      return;
    }
    if (password !== confirmPassword) {
      el('authError').textContent = 'Passwords do not match.';
      return;
    }
    if (password.length < 6) {
      el('authError').textContent = 'Password must be at least 6 characters.';
      return;
    }
    try {
      const userRef = doc(db, 'users', username);
      const userSnap = await getDoc(userRef);
      if (userSnap.exists()) {
        el('authError').textContent = 'Username already taken.';
        return;
      }
      await setDoc(userRef, { password, balance: 100 });
      el('authError').textContent = 'Sign-up successful! Please log in.';
      el('showLogin').click();
    } catch (error) {
      console.error('Signup error:', error, { code: error.code, message: error.message });
      if (error.code === 'unavailable' || error.message.includes('offline')) {
        el('authError').textContent = 'Cannot connect to the server. Please check your internet connection.';
      } else if (error.code === 'permission-denied') {
        el('authError').textContent = 'Permission denied. Contact support.';
      } else if (error.code === 'invalid-argument') {
        el('authError').textContent = 'Invalid username format. Use 3-20 alphanumeric characters, dashes, or underscores.';
      } else {
        el('authError').textContent = `Signup error: ${error.message}`;
      }
    }
  });

  el('logoutBtn').addEventListener('click', async () => {
    try {
      await updateUserBalance();
    } catch (error) {
      console.error('Logout update error:', error);
    }
    if (unsubscribeWagers) {
      unsubscribeWagers();
      unsubscribeWagers = null;
    }
    if (state.matchListener) {
      state.matchListener();
      state.matchListener = null;
    }
    state.loggedIn = false;
    state.username = '';
    state.balance = 100;
    state.wagers = [];
    state.ongoing = false;
    state.currentMatch = null;
    el('gameScreen').style.display = 'none';
    el('loginScreen').style.display = 'flex';
    el('loginUsername').value = '';
    el('loginPassword').value = '';
    el('signupUsername').value = '';
    el('signupPassword').value = '';
    el('signupConfirmPassword').value = '';
    el('authError').textContent = '';
    setStatus('Not Ready');
  });
}

/* ====== Wager Listener ====== */
function setupWagerListener() {
  const q = query(collection(db, 'wagers'), where('accepted', '==', false), orderBy('createdAt', 'desc'));
  unsubscribeWagers = onSnapshot(q, (snap) => {
    state.wagers = snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    if (!state.ongoing) renderAreas();
  }, (error) => {
    console.error('Wager listener error:', error);
    setStatus('Error loading wagers.');
  });
}

/* ====== Menu Selection ====== */
function setupMenus() {
  const menu = el('menu1');
  menu.addEventListener('click', e => {
    const opt = e.target.closest('.game-option');
    if (!opt) return;
    menu.querySelectorAll('.game-option').forEach(o => o.classList.remove('active'));
    opt.classList.add('active');
    state.selectedGame = opt.dataset.game;
    setStatus('Selected: ' + opt.textContent.trim());
  });
}

/* ====== Wager Buttons ====== */
function setupWagers() {
  el('create1').addEventListener('click', () => createWager());
  el('area1').addEventListener('click', e => handleWagerClick(e));
}

/* ====== Create Wager ====== */
async function createWager() {
  if (state.ongoing) return;
  if (!navigator.onLine) {
    alert('You are offline. Please connect to the internet.');
    return;
  }
  const stake = Number(el('stake1').value) || 1;
  if (stake < 1) {
    alert("Stake must be at least 1.");
    return;
  }
  if (state.balance < stake) {
    alert("Not enough Tokens to stake.");
    return;
  }
  const game = state.selectedGame;
  try {
    const docRef = await addDoc(collection(db, 'wagers'), {
      proposer: state.username,
      game,
      stake,
      createdAt: serverTimestamp(),
      accepted: false
    });
    setStatus('Wager created. Waiting for opponent...');
    setTimeout(async () => {
      try {
        const docSnap = await getDoc(docRef);
        if (docSnap.exists() && !docSnap.data().accepted) {
          await deleteDoc(docRef);
          startMatch(game, stake, { opponentIsBot: true });
        }
      } catch (error) {
        console.error('Bot fallback error:', error);
        setStatus('Error starting bot match.');
      }
    }, 30000);
  } catch (error) {
    console.error('Create wager error:', error);
    alert(`Error creating wager: ${error.message}`);
  }
}

/* ====== Handle Wager Click ====== */
async function handleWagerClick(e) {
  if (!navigator.onLine) {
    alert('You are offline. Please connect to the internet.');
    return;
  }
  const cancel = e.target.closest('.cancel-btn');
  if (cancel) {
    const id = cancel.dataset.id;
    const w = state.wagers.find(w => w.id === id);
    if (w && w.proposer === state.username) {
      try {
        await deleteDoc(doc(db, 'wagers', id));
        setStatus('Wager cancelled.');
      } catch (error) {
        console.error('Cancel wager error:', error);
        alert(`Error cancelling wager: ${error.message}`);
      }
    } else {
      alert("Cannot cancel this wager.");
    }
    return;
  }
  const accept = e.target.closest('.accept-btn');
  if (accept) {
    const id = accept.dataset.id;
    const w = state.wagers.find(w => w.id === id);
    if (!w) return;
    if (w.proposer === state.username) {
      alert('You cannot accept your own wager.');
      return;
    }
    if (state.balance < w.stake) {
      alert('Not enough Tokens to accept.');
      return;
    }
    try {
      const opponentRef = doc(db, 'users', w.proposer);
      const opponentSnap = await getDoc(opponentRef);
      if (!opponentSnap.exists() || opponentSnap.data().balance < w.stake) {
        alert('Opponent does not have enough Tokens.');
        return;
      }
      await updateDoc(doc(db, 'wagers', id), { accepted: true });
      const matchRef = await addDoc(collection(db, 'matches'), {
        game: w.game,
        stake: w.stake,
        proposer: w.proposer,
        opponent: state.username,
        createdAt: serverTimestamp(),
        status: 'active',
        actions: {}
      });
      await updateDoc(doc(db, 'users', w.proposer), {
        balance: opponentSnap.data().balance - w.stake
      });
      startMatch(w.game, w.stake, { matchId: matchRef.id, opponent: w.proposer });
    } catch (error) {
      console.error('Accept wager error:', error);
      alert(`Error accepting wager: ${error.message}`);
    }
  }
}

/* ====== Render Areas with Wagers ====== */
function renderAreas() {
  if (state.ongoing) return;
  const areaEl = el('area1');
  areaEl.innerHTML = '';
  if (state.wagers.length === 0) {
    areaEl.innerHTML = '<div class="center muted">No open challenges. Create one!</div>';
    return;
  }
  state.wagers.forEach(w => {
    const box = document.createElement('div');
    box.className = 'panel';
    box.style.marginBottom = '12px';
    let actionBtn = '';
    if (w.proposer === state.username) {
      actionBtn = `<button class="primary cancel-btn" data-id="${w.id}" style="background:#ff6b6b;color:#fff">Cancel</button>`;
    } else {
      actionBtn = `<button class="primary accept-btn" data-id="${w.id}" style="background:#4caf50;color:#fff">Accept</button>`;
    }
    box.innerHTML = `
      <div>Challenger: ${w.proposer}</div>
      <div>Game: ${prettyGameName(w.game)}</div>
      <div>Stake: ${w.stake} tokens</div>
      <div class="controls" style="justify-content: space-around">
        ${actionBtn}
      </div>`;
    areaEl.appendChild(box);
  });
}

/* ====== Match Lifecycle ====== */
async function startMatch(game, stake, opts = {}) {
  const opponentIsBot = !!opts.opponentIsBot;
  state.ongoing = true;
  state.currentMatch = { game, stake, startedAt: Date.now(), opponentIsBot, matchId: opts.matchId, opponent: opts.opponent };
  state.balance -= stake;
  updateBalance();
  await updateUserBalance();
  setStatus('Match starting: ' + prettyGameName(game));
  renderGameUI(game);
}

/* ====== Rendering per-game UI ====== */
function prettyGameName(k) {
  return ({ reaction: 'Reaction Duel', math: 'Math Sprint', ttt: 'Tic Tac Toe' })[k] || k;
}

function renderGameUI(game) {
  el('area1').innerHTML = '';
  if (game === 'reaction') renderReaction();
  else if (game === 'math') renderMathSprint();
  else if (game === 'ttt') renderTicTacToe();
}

/* ====== Reaction Duel ====== */
function renderReaction() {
  const area = el('area1');
  const box = document.createElement('div');
  box.className = 'go-box center';
  box.style.width = '100%';
  const text = document.createElement('div');
  text.className = 'countdown';
  text.textContent = 'Get Ready...';
  const btn = document.createElement('button');
  btn.className = 'large-btn';
  btn.textContent = 'PRESS';
  btn.disabled = true;
  box.append(text, document.createElement('br'), btn);
  area.appendChild(box);
  let go = false, resolved = false;
  let botTimeoutId = null;

  btn.addEventListener('click', async () => {
    if (resolved) return;
    const reactionTime = Date.now() - state.currentMatch.startedAt;
    if (!go && !state.currentMatch.opponentIsBot) {
      resolved = true;
      try {
        await updateDoc(doc(db, 'matches', state.currentMatch.matchId), {
          [`actions.${state.username}`]: { time: reactionTime, foul: true }
        });
      } catch (error) {
        console.error('Reaction update error:', error);
        setStatus('Error recording reaction.');
      }
      return;
    }
    if (state.currentMatch.opponentIsBot) {
      handleBotReaction(reactionTime);
    } else {
      try {
        await updateDoc(doc(db, 'matches', state.currentMatch.matchId), {
          [`actions.${state.username}`]: { time: reactionTime, foul: !go }
        });
      } catch (error) {
        console.error('Reaction update error:', error);
        setStatus('Error recording reaction.');
      }
    }
  });

  function handleBotReaction(playerTime) {
    if (resolved) return;
    resolved = true;
    const botTime = botTimeoutId ? (Date.now() - state.currentMatch.startedAt) : playerTime + Math.random() * 500 - 250;
    if (!go) {
      finalizeMatch(false, 'Clicked early (foul).');
    } else if (playerTime < botTime) {
      finalizeMatch(true, 'You reacted faster!');
    } else {
      finalizeMatch(false, 'Bot reacted faster!');
    }
    if (botTimeoutId) clearTimeout(botTimeoutId);
  }

  const delay = 1200 + Math.floor(Math.random() * 2000);
  setTimeout(() => {
    go = true;
    text.textContent = 'GO!';
    btn.disabled = false;
    if (state.currentMatch.opponentIsBot) {
      const botDelay = 200 + Math.floor(Math.random() * 400);
      botTimeoutId = setTimeout(() => {
        if (resolved) return;
        resolved = true;
        finalizeMatch(false, 'Bot reacted faster!');
      }, botDelay);
    }
  }, delay);

  if (!state.currentMatch.opponentIsBot) {
    state.matchListener = onSnapshot(doc(db, 'matches', state.currentMatch.matchId), (snap) => {
      if (!snap.exists()) {
        if (!resolved) {
          resolved = true;
          finalizeMatch(false, 'Match cancelled.');
        }
        return;
      }
      if (resolved) return;
      const data = snap.data();
      if (data.status === 'finished') {
        resolved = true;
        const myAction = data.actions[state.username] || {};
        const oppAction = data.actions[state.currentMatch.opponent] || {};
        if (myAction.foul) {
          finalizeMatch(false, 'You clicked early (foul).');
        } else if (oppAction.foul) {
          finalizeMatch(true, 'Opponent clicked early (foul).');
        } else if (myAction.time && oppAction.time) {
          finalizeMatch(myAction.time < oppAction.time, `You reacted ${myAction.time < oppAction.time ? 'faster' : 'slower'}!`);
        } else if (myAction.time) {
          finalizeMatch(true, 'Opponent did not react.');
        }
      }
    }, (error) => {
      console.error('Match listener error:', error);
      setStatus('Error in match.');
    });
  }

  setTimeout(() => {
    if (!resolved) {
      resolved = true;
      if (state.currentMatch.opponentIsBot) {
        finalizeMatch(false, 'No one reacted in time.');
      } else {
        try {
          updateDoc(doc(db, 'matches', state.currentMatch.matchId), { status: 'finished' });
        } catch (error) {
          console.error('Timeout update error:', error);
          setStatus('Error ending match.');
        }
      }
    }
  }, 8000);
}

/* ====== Math Sprint ====== */
function renderMathSprint() {
  const area = el('area1');
  const problem = generateMathProblem();
  const box = document.createElement('div');
  box.style.width = '100%';
  box.innerHTML = `
    <div style="font-weight:700;margin-bottom:8px">Solve: ${problem.question}</div>
    <div class="go-box" style="margin-bottom:8px"><div style="font-size:22px">${problem.question}</div></div>
    <input id="input1" type="number" class="stake-input" placeholder="Your answer" />
    <div style="margin-top:8px"><button id="submit1" class="primary">Submit</button></div>
    <div id="msg1" class="small muted" style="margin-top:8px"></div>`;
  area.appendChild(box);
  let resolved = false;
  const startTime = Date.now();

  const submit = el('submit1');
  const inp = el('input1');
  submit.addEventListener('click', async () => {
    if (resolved) return;
    const value = inp.value;
    const numeric = Number(value);
    const msg = el('msg1');
    if (isNaN(numeric)) { msg.textContent = 'Enter a number.'; return; }
    const correct = numeric === problem.answer;
    const time = Date.now() - startTime;
    msg.textContent = correct ? `Correct! (${time} ms)` : `Wrong (${time} ms)`;
    if (state.currentMatch.opponentIsBot) {
      handleBotMath(correct, time, numeric, problem.answer);
    } else {
      try {
        await updateDoc(doc(db, 'matches', state.currentMatch.matchId), {
          [`actions.${state.username}`]: { answer: numeric, time, correct }
        });
      } catch (error) {
        console.error('Math update error:', error);
        setStatus('Error recording answer.');
      }
    }
  });

  function handleBotMath(correct, time, numeric, answer) {
    if (resolved) return;
    resolved = true;
    const willBeCorrect = Math.random() < 0.8;
    const botTime = time + Math.random() * 1000 - 500;
    if (correct) {
      if (willBeCorrect) {
        finalizeMatch(time < botTime, time < botTime ? `Answered correctly in ${time} ms` : 'Bot answered faster!');
      } else {
        finalizeMatch(true, `Answered correctly in ${time} ms`);
      }
    } else {
      const d1 = Math.abs(numeric - answer);
      const d2 = Math.abs((Math.random() * 20 - 10) - answer);
      if (d1 < d2) finalizeMatch(true, 'Both wrong, but you were closer!');
      else finalizeMatch(false, 'Both wrong, bot was closer!');
    }
  }

  if (state.currentMatch.opponentIsBot) {
    const willBeCorrect = Math.random() < 0.8;
    const botDelay = 400 + Math.floor(Math.random() * 1600);
    setTimeout(() => {
      if (resolved) return;
      resolved = true;
      const time = Date.now() - startTime;
      if (willBeCorrect) {
        finalizeMatch(false, 'Bot answered correctly first!');
      } else {
        const v1 = Number(el('input1').value);
        const d1 = isNaN(v1) ? Infinity : Math.abs(v1 - problem.answer);
        const d2 = Math.abs((Math.random() * 20 - 10) - problem.answer);
        if (d1 === d2) finalizeDraw('No decisive answer ‚Äî draw');
        else finalizeMatch(d1 < d2, 'Time end ‚Äî closer answer wins');
      }
    }, botDelay);
  } else {
    state.matchListener = onSnapshot(doc(db, 'matches', state.currentMatch.matchId), (snap) => {
      if (!snap.exists()) {
        if (!resolved) {
          resolved = true;
          finalizeMatch(false, 'Match cancelled.');
        }
        return;
      }
      if (resolved) return;
      const data = snap.data();
      if (data.status === 'finished') {
        resolved = true;
        const myAction = data.actions[state.username] || {};
        const oppAction = data.actions[state.currentMatch.opponent] || {};
        if (myAction.correct && oppAction.correct) {
          finalizeMatch(myAction.time < oppAction.time, `You answered ${myAction.time < oppAction.time ? 'faster' : 'slower'}!`);
        } else if (myAction.correct) {
          finalizeMatch(true, 'You answered correctly!');
        } else if (oppAction.correct) {
          finalizeMatch(false, 'Opponent answered correctly!');
        } else {
          const d1 = myAction.answer ? Math.abs(myAction.answer - problem.answer) : Infinity;
          const d2 = oppAction.answer ? Math.abs(oppAction.answer - problem.answer) : Infinity;
          if (d1 === d2) finalizeDraw('No decisive answer ‚Äî draw');
          else finalizeMatch(d1 < d2, 'Closer answer wins');
        }
      }
    }, (error) => {
      console.error('Match listener error:', error);
      setStatus('Error in match.');
    });
  }

  setTimeout(() => {
    if (!resolved) {
      resolved = true;
      if (state.currentMatch.opponentIsBot) {
        const v1 = Number(el('input1').value);
        const d1 = isNaN(v1) ? Infinity : Math.abs(v1 - problem.answer);
        const d2 = Math.abs((Math.random() * 20 - 10) - problem.answer);
        if (d1 === d2) finalizeDraw('No decisive answer ‚Äî draw');
        else finalizeMatch(d1 < d2, 'Time end ‚Äî closer answer wins');
      } else {
        try {
          updateDoc(doc(db, 'matches', state.currentMatch.matchId), { status: 'finished' });
        } catch (error) {
          console.error('Timeout update error:', error);
          setStatus('Error ending match.');
        }
      }
    }
  }, 10000);
}

function generateMathProblem() {
  const ops = ['+', '-', '*'];
  const op = ops[Math.floor(Math.random() * ops.length)];
  let a = Math.floor(Math.random() * 12) + 1;
  let b = Math.floor(Math.random() * 12) + 1;
  if (op === '-' && b > a) { [a, b] = [b, a]; }
  const question = `${a} ${op} ${b}`;
  let answer;
  if (op === '+') answer = a + b;
  if (op === '-') answer = a - b;
  if (op === '*') answer = a * b;
  return { question, answer };
}

/* ====== Tic Tac Toe ====== */
function renderTicTacToe() {
  const area = el('area1');
  const board = document.createElement('div');
  board.style.width = '100%';
  board.className = 'center';
  const grid = document.createElement('div');
  grid.className = 'ttt-grid';
  const cells = [];
  for (let i = 0; i < 9; i++) {
    const c = document.createElement('div');
    c.className = 'ttt-cell';
    c.dataset.idx = i;
    c.addEventListener('click', () => tttClick(i));
    cells.push(c);
    grid.appendChild(c);
  }
  board.appendChild(grid);
  area.appendChild(board);
  let gameBoard = Array(9).fill(null);
  let currentPlayer = state.currentMatch.opponentIsBot ? 1 : (state.username === state.currentMatch.proposer ? 1 : 2);
  setStatus(`TicTacToe ‚Äî ${currentPlayer === 1 ? 'Your turn (X)' : 'Opponent\'s turn (O)'}`);

  function syncRender(boardState) {
    cells.forEach((cell, i) => {
      cell.textContent = boardState[i] === 1 ? 'X' : boardState[i] === 2 ? 'O' : '';
    });
  }

  async function tttClick(i) {
    if (gameBoard[i] !== null || currentPlayer !== 1 || state.ongoing === false) return;
    gameBoard[i] = 1;
    syncRender(gameBoard);
    if (state.currentMatch.opponentIsBot) {
      const winner = checkTTTWinner(gameBoard);
      if (winner) {
        finalizeMatch(winner === 1, `TicTacToe ‚Äî ${winner === 1 ? 'You win' : 'Bot wins'}`);
        return;
      }
      if (gameBoard.every(v => v !== null)) {
        finalizeDraw('TicTacToe ‚Äî Draw');
        return;
      }
      currentPlayer = 2;
      setStatus('TicTacToe ‚Äî Bot\'s turn (O)');
      setTimeout(() => {
        const available = gameBoard.map((v, i) => v === null ? i : null).filter(v => v !== null);
        if (available.length > 0) {
          const move = tttBotChooseMove(gameBoard, 2, 1);
          gameBoard[move] = 2;
          syncRender(gameBoard);
          const winner = checkTTTWinner(gameBoard);
          if (winner) {
            finalizeMatch(winner === 1, `TicTacToe ‚Äî ${winner === 1 ? 'You win' : 'Bot wins'}`);
            return;
          }
          if (gameBoard.every(v => v !== null)) {
            finalizeDraw('TicTacToe ‚Äî Draw');
            return;
          }
          currentPlayer = 1;
          setStatus('TicTacToe ‚Äî Your turn (X)');
        }
      }, 500);
    } else {
      try {
        await updateDoc(doc(db, 'matches', state.currentMatch.matchId), {
          [`actions.board`]: gameBoard,
          currentPlayer: 2
        });
      } catch (error) {
        console.error('TTT update error:', error);
        setStatus('Error recording move.');
      }
    }
  }

  if (!state.currentMatch.opponentIsBot) {
    state.matchListener = onSnapshot(doc(db, 'matches', state.currentMatch.matchId), (snap) => {
      if (!snap.exists()) {
        if (!state.ongoing) return;
        finalizeMatch(false, 'Match cancelled.');
        return;
      }
      if (!state.ongoing) return;
      const data = snap.data();
      gameBoard = data.actions.board || Array(9).fill(null);
      currentPlayer = data.currentPlayer || (state.username === state.currentMatch.proposer ? 1 : 2);
      syncRender(gameBoard);
      setStatus(`TicTacToe ‚Äî ${currentPlayer === 1 ? 'Your turn (X)' : 'Opponent\'s turn (O)'}`);
      const winner = checkTTTWinner(gameBoard);
      if (winner) {
        finalizeMatch(winner === 1, `TicTacToe ‚Äî ${winner === 1 ? 'You win' : 'Opponent wins'}`);
      } else if (gameBoard.every(v => v !== null)) {
        finalizeDraw('TicTacToe ‚Äî Draw');
      }
    }, (error) => {
      console.error('Match listener error:', error);
      setStatus('Error in match.');
    });
  }

  function checkTTTWinner(b) {
    const lines = [[0,1,2], [3,4,5], [6,7,8], [0,3,6], [1,4,7], [2,5,8], [0,4,8], [2,4,6]];
    for (const [a, b, c] of lines) {
      if (b[a] && b[a] === b[b] && b[a] === b[c]) return b[a];
    }
    return null;
  }

  function tttBotChooseMove(board, myMark = 2, oppMark = 1) {
    const lines = [[0,1,2], [3,4,5], [6,7,8], [0,3,6], [1,4,7], [2,5,8], [0,4,8], [2,4,6]];
    for (const mark of [myMark, oppMark]) {
      for (const [a,b,c] of lines) {
        const vals = [board[a], board[b], board[c]];
        const empties = [a,b,c].filter(i => board[i] === null);
        const countMark = vals.filter(v => v === mark).length;
        if (countMark === 2 && empties.length === 1) return empties[0];
      }
    }
    if (board[4] === null) return 4;
    const corners = [0,2,6,8].filter(i => board[i] === null);
    if (corners.length > 0) return corners[Math.floor(Math.random() * corners.length)];
    const empties = board.map((v,i) => v === null ? i : null).filter(v => v !== null);
    return empties[Math.floor(Math.random() * empties.length)];
  }
}

/* ====== Finalize Match Results ====== */
async function finalizeMatch(won, reason = '') {
  const stake = state.currentMatch.stake;
  if (won) state.balance += stake * 2;
  updateBalance();
  await updateUserBalance();
  if (won) el('area1').parentElement.classList.add('glow-win');
  if (!state.currentMatch.opponentIsBot) {
    try {
      await updateDoc(doc(db, 'matches', state.currentMatch.matchId), { status: 'finished' });
    } catch (error) {
      console.error('Finalize match error:', error);
      setStatus('Error finalizing match.');
    }
  }
  concludeMatchUI(won ? `You win! ${reason}` : `Opponent wins! ${reason}`);
}

async function finalizeDraw(reason = '') {
  const stake = state.currentMatch.stake;
  state.balance += stake;
  updateBalance();
  await updateUserBalance();
  if (!state.currentMatch.opponentIsBot) {
    try {
      await updateDoc(doc(db, 'matches', state.currentMatch.matchId), { status: 'finished' });
    } catch (error) {
      console.error('Finalize draw error:', error);
      setStatus('Error finalizing match.');
    }
  }
  concludeMatchUI('Draw! ' + reason);
}

function concludeMatchUI(message) {
  state.ongoing = false;
  state.currentMatch = null;
  if (state.matchListener) {
    state.matchListener();
    state.matchListener = null;
  }
  setStatus(message);
  setTimeout(() => {
    el('area1').innerHTML = '';
    renderAreas();
    el('area1').parentElement.classList.remove('glow-win');
  }, 1600);
}

/* ====== Init ====== */
setupAuth();
setupMenus();
setupWagers();
updateBalance();
</script>
</body>
</html>
