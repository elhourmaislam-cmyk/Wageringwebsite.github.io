<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Challenge Arena ‚Äî Tokens</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #050507;
  --panel: #0f1113;
  --accent1: #00ffff;
  --accent2: #7cff66;
  --glass: rgba(255,255,255,0.03);
}
* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; font-family: 'Poppins', sans-serif; background: radial-gradient(1200px 600px at 10% 10%, rgba(0,255,204,0.03), transparent), linear-gradient(180deg,#030304 0%, #07070a 100%); color: #eafcff; }
.container { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; padding: 24px; }
.panel { width: 100%; max-width: 500px; background: var(--panel); border-radius: 12px; padding: 14px; box-shadow: 0 6px 28px rgba(2,8,12,0.6), inset 0 0 30px rgba(0,255,204,0.02); border: 1px solid rgba(0,255,204,0.06); }
header { width: 100%; text-align: center; margin-bottom: 12px; }
h2 { margin: 6px 0; font-size: 20px; letter-spacing: 1px; }
.balance { margin: 6px 0; color: var(--accent2); font-weight: 600; }
button.primary { margin-top: 10px; padding: 10px 14px; border-radius: 10px; border: none; font-weight: 700; cursor: pointer; background: linear-gradient(90deg, var(--accent1), var(--accent2)); color: #001; box-shadow: 0 6px 18px rgba(0,255,204,0.08); }
.muted { color: #9fb8b2; font-size: 13px; }
.controls { display: flex; gap: 10px; margin-top: 10px; align-items: center; justify-content: center; }
.stake-input { width: 110px; padding: 8px; border-radius: 8px; border: 1px solid rgba(0,255,204,0.08); background: #050607; color: var(--accent1); font-weight: 600; text-align: center; }
.game-menu { display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap; justify-content: center; }
.game-option { padding: 8px 10px; border-radius: 10px; background: var(--glass); border: 1px solid rgba(255,255,255,0.02); cursor: pointer; font-weight: 600; }
.game-option.active { box-shadow: 0 8px 28px rgba(0,255,204,0.06); border: 1px solid rgba(0,255,204,0.12); }
.board-area { margin-top: 14px; width: 100%; display: flex; justify-content: center; align-items: center; min-height: 220px; flex-direction: column; }
.status { margin-top: 10px; font-weight: 600; color: #cde; text-align: center; }
.ready-btn { width: 120px; }
.large-btn { padding: 18px 22px; font-size: 18px; border-radius: 12px; background: linear-gradient(90deg, var(--accent1), var(--accent2)); color: #001; border: none; cursor: pointer; }
.go-box { padding: 22px 18px; border-radius: 12px; background: #020304; border: 1px solid rgba(0,255,204,0.06); }
.countdown { font-size: 28px; font-weight: 700; letter-spacing: 2px; }
.ttt-grid { display: grid; grid-template-columns: repeat(3, 80px); gap: 8px; justify-content: center; }
.ttt-cell { width: 80px; height: 80px; border-radius: 10px; background: #080a0b; display: flex; align-items: center; justify-content: center; font-size: 34px; cursor: pointer; border: 1px solid rgba(0,255,204,0.03); }
.ttt-cell:hover { transform: translateY(-3px); }
.topbar { position: fixed; top: 14px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; align-items: center; z-index: 30; }
.title { font-size: 20px; font-weight: 700; background: linear-gradient(90deg, var(--accent1), var(--accent2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.global-controls { display: flex; gap: 8px; align-items: center; background: rgba(0,0,0,0.45); padding: 8px 12px; border-radius: 12px; border: 1px solid rgba(0,255,204,0.04); }
.small { font-size: 13px; color: #9fc9c2; }
.glow-win { box-shadow: 0 0 30px rgba(124,255,102,0.12), 0 0 80px rgba(0,255,204,0.03); }
.center { display: flex; align-items: center; justify-content: center; }
.login-container { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
.login-panel { background: var(--panel); padding: 20px; border-radius: 12px; width: 300px; text-align: center; }
.login-input { width: 100%; padding: 8px; margin: 8px 0; border-radius: 8px; border: 1px solid rgba(0,255,204,0.08); background: #050607; color: var(--accent1); }
.login-btn { width: 100%; }
.toggle-btn { cursor: pointer; color: var(--accent1); text-decoration: underline; margin-top: 10px; }
</style>
</head>
<body>
<div class="login-container" id="loginScreen">
  <div class="login-panel" id="authPanel">
    <h2 id="authTitle">Login to Challenge Arena</h2>
    <div id="loginForm">
      <input id="loginUsername" class="login-input" type="email" placeholder="Email" />
      <input id="loginPassword" class="login-input" type="password" placeholder="Password" />
      <button class="primary login-btn" id="loginBtn">Login</button>
      <div class="small muted toggle-btn" id="showSignup">Need an account? Sign Up</div>
    </div>
    <div id="signupForm" style="display: none;">
      <input id="signupUsername" class="login-input" type="email" placeholder="Email" />
      <input id="signupPassword" class="login-input" type="password" placeholder="Password" />
      <input id="signupConfirmPassword" class="login-input" type="password" placeholder="Confirm Password" />
      <button class="primary login-btn" id="signupBtn">Sign Up</button>
      <div class="small muted toggle-btn" id="showLogin">Already have an account? Login</div>
    </div>
    <div id="authError" class="small muted" style="margin-top: 8px;"></div>
  </div>
</div>
<div class="container" id="gameScreen" style="display: none;">
  <div class="topbar">
    <div class="title">üí† Challenge Arena</div>
    <div class="global-controls">
      <button class="primary small" id="logoutBtn">Logout</button>
    </div>
  </div>
  <header>
    <h2 id="playerName">Player</h2>
    <div class="balance">Tokens: <span id="bal1">100</span></div>
  </header>
  <div class="panel">
    <div class="small muted center">Game Selection</div>
    <div class="game-menu" id="menu1">
      <div class="game-option active" data-game="reaction">‚ö° Reaction Duel</div>
      <div class="game-option" data-game="math">üßÆ Math Sprint</div>
      <div class="game-option" data-game="ttt">‚ùå‚≠ï Tic Tac Toe</div>
    </div>
    <div class="small muted center" style="margin-top:12px">Stake Amount</div>
    <div class="controls">
      <input id="stake1" class="stake-input" type="number" value="10" min="1" />
      <div class="muted">Tokens</div>
    </div>
    <div class="controls">
      <button class="primary ready-btn" id="create1">Create Challenge</button>
    </div>
    <div class="board-area" id="area1"></div>
    <div class="status" id="status1">Not Ready</div>
  </div>
</div>
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, collection, addDoc, query, where, orderBy, onSnapshot, serverTimestamp, deleteDoc } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js";

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyCxU57etJTjzv2hCqFFYqQyHEQcoebfsHE",
  authDomain: "wagering-59415.firebaseapp.com",
  projectId: "wagering-59415",
  storageBucket: "wagering-59415.firebasestorage.app",
  messagingSenderId: "1063169096719",
  appId: "1:1063169096719:web:e10a094630347b5fffb77a",
  measurementId: "G-PNND9Q37XQ"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

/* ====== State ====== */
const state = {
  loggedIn: false,
  userId: '',  // Use UID instead of username
  username: '',  // We'll set this to email for display
  balance: 100,
  selectedGame: 'reaction',
  ongoing: false,
  currentMatch: null,
  wagers: []
};

/* ====== Helpers ====== */
const el = id => document.getElementById(id);
function setStatus(txt) { el('status1').textContent = txt; }
function updateBalance() { el('bal1').textContent = state.balance; }
let unsubscribeWagers = null;

/* ====== User Balance Update ====== */
async function updateUserBalance() {
  if (state.userId) {
    await updateDoc(doc(db, 'users', state.userId), { balance: state.balance });
  }
}

/* ====== Fetch User Data ====== */
async function fetchUserData(user) {
  const userDoc = doc(db, 'users', user.uid);
  const userSnap = await getDoc(userDoc);
  if (userSnap.exists()) {
    state.balance = userSnap.data().balance || 100;
  } else {
    // If no doc, create one
    await setDoc(userDoc, { balance: 100 });
    state.balance = 100;
  }
  updateBalance();
}

/* ====== Auth System ====== */
function setupAuth() {
  // Listen for auth state changes (persists login)
  onAuthStateChanged(auth, (user) => {
    if (user) {
      state.loggedIn = true;
      state.userId = user.uid;
      state.username = user.email;  // Use email as display name
      el('loginScreen').style.display = 'none';
      el('gameScreen').style.display = 'flex';
      el('playerName').textContent = state.username;
      fetchUserData(user);
      renderAreas();
      setupWagerListener();
    } else {
      state.loggedIn = false;
      state.userId = '';
      state.username = '';
      state.balance = 100;
      el('gameScreen').style.display = 'none';
      el('loginScreen').style.display = 'flex';
    }
  });

  // Toggle between login and signup
  el('showSignup').addEventListener('click', () => {
    el('loginForm').style.display = 'none';
    el('signupForm').style.display = 'block';
    el('authTitle').textContent = 'Sign Up for Challenge Arena';
    el('authError').textContent = '';
    el('loginUsername').value = '';
    el('loginPassword').value = '';
  });

  el('showLogin').addEventListener('click', () => {
    el('signupForm').style.display = 'none';
    el('loginForm').style.display = 'block';
    el('authTitle').textContent = 'Login to Challenge Arena';
    el('authError').textContent = '';
    el('signupUsername').value = '';
    el('signupPassword').value = '';
    el('signupConfirmPassword').value = '';
  });

  // Login
  el('loginBtn').addEventListener('click', async () => {
    const email = el('loginUsername').value.trim();
    const password = el('loginPassword').value.trim();
    try {
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      // Auth state change will handle the rest
    } catch (error) {
      el('authError').textContent = 'Error: ' + (error.message || 'Login failed');
    }
  });

  // Sign Up
  el('signupBtn').addEventListener('click', async () => {
    const email = el('signupUsername').value.trim();
    const password = el('signupPassword').value.trim();
    const confirmPassword = el('signupConfirmPassword').value.trim();
    if (!email || !password || !confirmPassword) {
      el('authError').textContent = 'All fields are required.';
      return;
    }
    if (password !== confirmPassword) {
      el('authError').textContent = 'Passwords do not match.';
      return;
    }
    try {
      const userCredential = await createUserWithEmailAndPassword(auth, email, password);
      const user = userCredential.user;
      // Create Firestore doc
      await setDoc(doc(db, 'users', user.uid), { balance: 100 });
      el('authError').textContent = 'Sign-up successful! Please log in.';
      el('showLogin').click();
    } catch (error) {
      el('authError').textContent = 'Error: ' + (error.message || 'Signup failed');
    }
  });

  // Logout
  el('logoutBtn').addEventListener('click', async () => {
    await updateUserBalance();
    if (unsubscribeWagers) unsubscribeWagers();
    await signOut(auth);
    // Auth state change will handle the rest
  });
}

/* ====== Wager Listener ====== */
function setupWagerListener() {
  const q = query(collection(db, 'wagers'), where('accepted', '==', false), orderBy('createdAt', 'desc'));
  unsubscribeWagers = onSnapshot(q, (snap) => {
    state.wagers = snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    if (!state.ongoing) renderAreas();
  });
}

/* ====== Menu Selection ====== */
function setupMenus() {
  const menu = el('menu1');
  menu.addEventListener('click', e => {
    const opt = e.target.closest('.game-option');
    if (!opt) return;
    menu.querySelectorAll('.game-option').forEach(o => o.classList.remove('active'));
    opt.classList.add('active');
    state.selectedGame = opt.dataset.game;
    setStatus('Selected: ' + opt.textContent.trim());
  });
}

/* ====== Wager Buttons ====== */
function setupWagers() {
  el('create1').addEventListener('click', () => createWager());
  el('area1').addEventListener('click', e => handleWagerClick(e));
}

/* ====== Create Wager ====== */
async function createWager() {
  if (state.ongoing || !auth.currentUser) return;
  const stake = Number(el('stake1').value) || 1;
  if (stake < 1) {
    alert("Stake must be at least 1.");
    return;
  }
  if (state.balance < stake) {
    alert("Not enough Tokens to stake.");
    return;
  }
  const game = state.selectedGame;
  const docRef = await addDoc(collection(db, 'wagers'), {
    proposer: auth.currentUser.uid,
    game,
    stake,
    createdAt: serverTimestamp(),
    accepted: false
  });
  setStatus('Wager created. Waiting for opponent...');
  // Simulate bot opponent: only accept after 30s if not accepted
  setTimeout(async () => {
    const docSnap = await getDoc(docRef);
    if (docSnap.exists() && !docSnap.data().accepted) {
      await deleteDoc(docRef);
      startMatch(game, stake, { opponentIsBot: true });
    }
  }, 30000);
}

/* ====== Handle Wager Click ====== */
async function handleWagerClick(e) {
  const cancel = e.target.closest('.cancel-btn');
  if (cancel) {
    const id = cancel.dataset.id;
    const w = state.wagers.find(w => w.id === id);
    if (w && w.proposer === auth.currentUser.uid) {
      await deleteDoc(doc(db, 'wagers', id));
      setStatus('Wager cancelled.');
    } else {
      alert("Cannot cancel this wager.");
    }
    return;
  }
  const accept = e.target.closest('.accept-btn');
  if (accept) {
    const id = accept.dataset.id;
    const w = state.wagers.find(w => w.id === id);
    if (!w) return;
    if (w.proposer === auth.currentUser.uid) { alert('You cannot accept your own wager.'); return; }
    await updateDoc(doc(db, 'wagers', id), { accepted: true });
    startMatch(w.game, w.stake);
    return;
  }
}

/* ====== Render Areas with Wagers ====== */
function renderAreas() {
  if (state.ongoing) return;
  const areaEl = el('area1');
  areaEl.innerHTML = '';
  if (state.wagers.length === 0) {
    areaEl.innerHTML = '<div class="center muted">No open challenges. Create one!</div>';
    return;
  }
  state.wagers.forEach(w => {
    const box = document.createElement('div');
    box.className = 'panel';
    box.style.marginBottom = '12px';
    let actionBtn = '';
    if (w.proposer === auth.currentUser?.uid) {
      actionBtn = `<button class="primary cancel-btn" data-id="${w.id}" style="background:#ff6b6b;color:#fff">Cancel</button>`;
    } else {
      actionBtn = `<button class="primary accept-btn" data-id="${w.id}" style="background:#4caf50;color:#fff">Accept</button>`;
    }
    box.innerHTML = `
      <div>Challenger: ${w.proposer}</div>  <!-- Note: This shows UID; you could fetch email if needed -->
      <div>Game: ${prettyGameName(w.game)}</div>
      <div>Stake: ${w.stake} tokens</div>
      <div class="controls" style="justify-content: space-around">
        ${actionBtn}
      </div>`;
    areaEl.appendChild(box);
  });
}

/* ====== Match Lifecycle ====== */
async function startMatch(game, stake, opts = {}) {
  const opponentIsBot = !!opts.opponentIsBot;
  state.ongoing = true;
  state.currentMatch = { game, stake, startedAt: Date.now(), opponentIsBot };
  state.balance -= stake;
  updateBalance();
  await updateUserBalance();
  setStatus('Match starting: ' + prettyGameName(game));
  renderGameUI(game);
}

/* ====== Rendering per-game UI ====== */
function prettyGameName(k) {
  return ({ reaction: 'Reaction Duel', math: 'Math Sprint', ttt: 'Tic Tac Toe' })[k] || k;
}

function renderGameUI(game) {
  el('area1').innerHTML = '';
  if (game === 'reaction') renderReaction();
  else if (game === 'math') renderMathSprint();
  else if (game === 'ttt') renderTicTacToe();
}

/* ====== Reaction Duel ====== */
function renderReaction() {
  const area = el('area1');
  const box = document.createElement('div');
  box.className = 'go-box center';
  box.style.width = '100%';
  const text = document.createElement('div');
  text.className = 'countdown';
  text.textContent = 'Get Ready...';
  const btn = document.createElement('button');
  btn.className = 'large-btn';
  btn.textContent = 'PRESS';
  btn.disabled = true;
  box.append(text, document.createElement('br'), btn);
  area.appendChild(box);
  let go = false, resolved = false;
  // Bot reaction helpers
  let botReacted = false;
  let botTimeoutId = null;
  btn.addEventListener('click', () => handleClick());
  function handleClick() {
    if (resolved) return;
    if (!go) {
      resolved = true;
      finalizeMatch(false, 'Clicked early (foul).');
      return;
    }
    resolved = true;
    const playerTime = Date.now() - state.currentMatch.startedAt;
    const opponentIsBot = state.currentMatch && state.currentMatch.opponentIsBot;
    if (opponentIsBot) {
      // If bot already reacted, player loses
      if (botReacted) { finalizeMatch(false, 'Bot reacted faster!'); return; }
      // Otherwise simulate bot time
      const opponentTime = (botTimeoutId ? (Date.now() - state.currentMatch.startedAt) : playerTime + Math.random() * 500 - 250);
      if (playerTime < opponentTime) finalizeMatch(true, 'You reacted faster!');
      else finalizeMatch(false, 'Bot reacted faster!');
      if (botTimeoutId) clearTimeout(botTimeoutId);
    } else {
      const opponentTime = playerTime + Math.random() * 500 - 250; // Simulate opponent
      if (playerTime < opponentTime) finalizeMatch(true, 'You reacted faster!');
      else finalizeMatch(false, 'Opponent reacted faster!');
    }
  }
  const delay = 1200 + Math.floor(Math.random() * 2000);
  setTimeout(() => {
    go = true;
    text.textContent = 'GO!';
    btn.disabled = false;
    // Schedule bot reaction when GO appears
    if (state.currentMatch && state.currentMatch.opponentIsBot) {
      const botDelay = 200 + Math.floor(Math.random() * 400); // 200 - 600ms
      botTimeoutId = setTimeout(() => {
        if (resolved) return;
        botReacted = true;
        resolved = true;
        finalizeMatch(false, 'Bot reacted faster!');
      }, botDelay);
    }
  }, delay);
  setTimeout(() => {
    if (!resolved) {
      resolved = true;
      finalizeMatch(false, 'No one reacted in time.');
    }
  }, 8000);
}

/* ====== Math Sprint ====== */
function renderMathSprint() {
  const area = el('area1');
  const problem = generateMathProblem();
  const box = document.createElement('div');
  box.style.width = '100%';
  box.innerHTML = `
    <div style="font-weight:700;margin-bottom:8px">Solve:</div>
    <div class="go-box" style="margin-bottom:8px"><div style="font-size:22px">${problem.question}</div></div>
    <input id="input1" type="number" class="stake-input" placeholder="Your answer" />
    <div style="margin-top:8px"><button id="submit1" class="primary">Submit</button></div>
    <div id="msg1" class="small muted" style="margin-top:8px"></div>`;
  area.appendChild(box);
  let resolved = false;
  const startTime = Date.now();
  // Bot answering state
  let botAnswered = false;
  let botAnswer = null;
  const submit = el('submit1');
  const inp = el('input1');
  submit.addEventListener('click', () => handleSubmit(inp.value));
  function handleSubmit(value) {
    if (resolved) return;
    const numeric = Number(value);
    const msg = el('msg1');
    if (isNaN(numeric)) { msg.textContent = 'Enter a number.'; return; }
    const correct = numeric === problem.answer;
    const time = Date.now() - startTime;
    msg.textContent = correct ? `Correct! (${time} ms)` : `Wrong (${time} ms)`;
    if (correct) {
      resolved = true;
      const opponentIsBot = state.currentMatch && state.currentMatch.opponentIsBot;
      if (opponentIsBot) {
        // If bot answered correctly earlier, player loses
        if (botAnswered && botAnswer && botAnswer.correct) {
          finalizeMatch(false, 'Bot answered first!');
          return;
        }
        const opponentTime = botAnswered && botAnswer ? botAnswer.time : (time + Math.random() * 1000 - 500);
        if (time < opponentTime) finalizeMatch(true, `Answered correctly in ${time} ms`);
        else finalizeMatch(false, 'Bot answered faster!');
      } else {
        const opponentTime = time + Math.random() * 1000 - 500;
        if (time < opponentTime) finalizeMatch(true, `Answered correctly in ${time} ms`);
        else finalizeMatch(false, 'Opponent answered faster!');
      }
    } else {
      resolved = true;
      const d1 = Math.abs(numeric - problem.answer);
      const d2 = Math.abs((Math.random() * 20 - 10) - problem.answer); // Simulate opponent
      if (d1 < d2) finalizeMatch(true, 'Both wrong, but you were closer!');
      else finalizeMatch(false, 'Both wrong, opponent was closer!');
    }
  }
  // If opponent is bot, schedule its answer
  if (state.currentMatch && state.currentMatch.opponentIsBot) {
    const willBeCorrect = Math.random() < 0.8; // 80% chance to be correct
    const botDelay = 400 + Math.floor(Math.random() * 1600); // 400-2000ms
    setTimeout(() => {
      if (resolved) return;
      botAnswered = true;
      botAnswer = { correct: willBeCorrect, time: Date.now() - startTime };
      if (willBeCorrect) {
        resolved = true;
        finalizeMatch(false, 'Bot answered correctly first!');
      }
    }, botDelay);
  }
  setTimeout(() => {
    if (!resolved) {
      resolved = true;
      const v1 = Number(el('input1').value);
      const d1 = isNaN(v1) ? Infinity : Math.abs(v1 - problem.answer);
      const d2 = Math.abs((Math.random() * 20 - 10) - problem.answer);
      if (d1 === d2) finalizeDraw('No decisive answer ‚Äî draw');
      else finalizeMatch(d1 < d2, 'Time end ‚Äî closer answer wins');
    }
  }, 10000);
}

function generateMathProblem() {
  const ops = ['+', '-', '*'];
  const op = ops[Math.floor(Math.random() * ops.length)];
  let a = Math.floor(Math.random() * 12) + 1;
  let b = Math.floor(Math.random() * 12) + 1;
  if (op === '-' && b > a) { [a, b] = [b, a]; }
  const question = `${a} ${op} ${b}`;
  let answer;
  if (op === '+') answer = a + b;
  if (op === '-') answer = a - b;
  if (op === '*') answer = a * b;
  return { question, answer };
}

/* ====== Tic Tac Toe ====== */
function renderTicTacToe() {
  const area = el('area1');
  const board = document.createElement('div');
  board.style.width = '100%';
  board.className = 'center';
  const grid = document.createElement('div');
  grid.className = 'ttt-grid';
  const cells = [];
  for (let i = 0; i < 9; i++) {
    const c = document.createElement('div');
    c.className = 'ttt-cell';
    c.dataset.idx = i;
    c.addEventListener('click', () => tttClick(i));
    cells.push(c);
    grid.appendChild(c);
  }
  board.appendChild(grid);
  area.appendChild(board);
  let gameBoard = Array(9).fill(null);
  let current = 1; // Player is X, opponent is O
  setStatus('TicTacToe ‚Äî Your turn (X)');
  function syncRender() {
    cells.forEach((cell, i) => {
      cell.textContent = gameBoard[i] === 1 ? 'X' : gameBoard[i] === 2 ? 'O' : '';
    });
  }
  function tttClick(i) {
    if (gameBoard[i] !== null || current !== 1 || state.ongoing === false) return;
    gameBoard[i] = 1;
    syncRender();
    const winner = checkTTTWinner(gameBoard);
    if (winner) {
      finalizeMatch(winner === 1, `TicTacToe ‚Äî ${winner === 1 ? 'You win' : 'Opponent wins'}`);
      return;
    }
    if (gameBoard.every(v => v !== null)) {
      finalizeDraw('TicTacToe ‚Äî Draw');
      return;
    }
    current = 2;
    setStatus('TicTacToe ‚Äî Opponent\'s turn (O)');
    // Simulate opponent move
    setTimeout(() => {
      const available = gameBoard.map((v, i) => v === null ? i : null).filter(v => v !== null);
      if (available.length > 0) {
        const opponentIsBot = state.currentMatch && state.currentMatch.opponentIsBot;
        let move;
        if (opponentIsBot) move = tttBotChooseMove(gameBoard, 2, 1);
        else move = available[Math.floor(Math.random() * available.length)];
        gameBoard[move] = 2;
        syncRender();
        const winner = checkTTTWinner(gameBoard);
        if (winner) {
          finalizeMatch(winner === 1, `TicTacToe ‚Äî ${winner === 1 ? 'You win' : 'Opponent wins'}`);
          return;
        }
        if (gameBoard.every(v => v !== null)) {
          finalizeDraw('TicTacToe ‚Äî Draw');
          return;
        }
        current = 1;
        setStatus('TicTacToe ‚Äî Your turn (X)');
      }
    }, 500);
  }
  function checkTTTWinner(b) {
    const lines = [ [0,1,2], [3,4,5], [6,7,8], [0,3,6], [1,4,7], [2,5,8], [0,4,8], [2,4,6] ];
    for (const [a, b2, c] of lines) {
      if (b[a] && b[a] === b[b2] && b[a] === b[c]) return b[a];
    }
    return null;
  }

  // Simple TTT bot: try to win, block player, take center, take corners, else random
  function tttBotChooseMove(board, myMark = 2, oppMark = 1) {
    const lines = [ [0,1,2], [3,4,5], [6,7,8], [0,3,6], [1,4,7], [2,5,8], [0,4,8], [2,4,6] ];
    // helper to find winning/blocking move
    for (const mark of [myMark, oppMark]) {
      for (const [a,b,c] of lines) {
        const vals = [board[a], board[b], board[c]];
        const empties = [a,b,c].filter(i => board[i] === null);
        const countMark = vals.filter(v => v === mark).length;
        if (countMark === 2 && empties.length === 1) return empties[0];
      }
    }
    // center
    if (board[4] === null) return 4;
    // corners
    const corners = [0,2,6,8].filter(i => board[i] === null);
    if (corners.length > 0) return corners[Math.floor(Math.random() * corners.length)];
    // fallback: any empty
    const empties = board.map((v,i) => v === null ? i : null).filter(v => v !== null);
    return empties[Math.floor(Math.random() * empties.length)];
  }
}

/* ====== Finalize Match Results ====== */
async function finalizeMatch(won, reason = '') {
  const stake = state.currentMatch.stake;
  if (won) state.balance += stake * 2;
  updateBalance();
  await updateUserBalance();
  if (won) el('area1').parentElement.classList.add('glow-win');
  concludeMatchUI(won ? `You win! ${reason}` : `Opponent wins! ${reason}`);
}

async function finalizeDraw(reason = '') {
  const stake = state.currentMatch.stake;
  state.balance += stake;
  updateBalance();
  await updateUserBalance();
  concludeMatchUI('Draw! ' + reason);
}

function concludeMatchUI(message) {
  state.ongoing = false;
  state.currentMatch = null;
  setStatus(message);
  setTimeout(() => {
    el('area1').innerHTML = '';
    renderAreas();
    el('area1').parentElement.classList.remove('glow-win');
  }, 1600);
}

/* ====== Init ====== */
setupAuth();
setupMenus();
setupWagers();
updateBalance();
</script>
</body>
</html>
